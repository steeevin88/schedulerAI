/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-ical";
exports.ids = ["vendor-chunks/node-ical"];
exports.modules = {

/***/ "(ssr)/./node_modules/node-ical/ical.js":
/*!****************************************!*\
  !*** ./node_modules/node-ical/ical.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable max-depth, max-params, no-warning-comments, complexity */\n\nconst {v4: uuid} = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/uuid/dist/esm-node/index.js\");\nconst moment = __webpack_require__(/*! moment-timezone */ \"(ssr)/./node_modules/moment-timezone/index.js\");\nconst rrule = (__webpack_require__(/*! rrule */ \"(ssr)/./node_modules/rrule/dist/es5/rrule.js\").RRule);\n\n/** **************\n *  A tolerant, minimal icalendar parser\n *  (http://tools.ietf.org/html/rfc5545)\n *\n *  <peterbraden@peterbraden.co.uk>\n * ************* */\n\n// Unescape Text re RFC 4.3.11\nconst text = function (t = '') {\n  return t\n    .replace(/\\\\,/g, ',')\n    .replace(/\\\\;/g, ';')\n    .replace(/\\\\[nN]/g, '\\n')\n    .replace(/\\\\\\\\/g, '\\\\');\n};\n\nconst parseValue = function (value) {\n  if (value === 'TRUE') {\n    return true;\n  }\n\n  if (value === 'FALSE') {\n    return false;\n  }\n\n  const number = Number(value);\n  if (!Number.isNaN(number)) {\n    return number;\n  }\n\n  return value;\n};\n\nconst parseParameters = function (p) {\n  const out = {};\n  for (const element of p) {\n    if (element.includes('=')) {\n      const segs = element.split('=');\n\n      out[segs[0]] = parseValue(segs.slice(1).join('='));\n    }\n  }\n\n  // Sp is not defined in this scope, typo?\n  // original code from peterbraden\n  // return out || sp;\n  return out;\n};\n\nconst storeValueParameter = function (name) {\n  return function (value, curr) {\n    const current = curr[name];\n\n    if (Array.isArray(current)) {\n      current.push(value);\n      return curr;\n    }\n\n    if (typeof current === 'undefined') {\n      curr[name] = value;\n    } else {\n      curr[name] = [current, value];\n    }\n\n    return curr;\n  };\n};\n\nconst storeParameter = function (name) {\n  return function (value, parameters, curr) {\n    const data = parameters && parameters.length > 0 && !(parameters.length === 1 && (parameters[0] === 'CHARSET=utf-8' || parameters[0] === 'VALUE=TEXT')) ? {params: parseParameters(parameters), val: text(value)} : text(value);\n\n    return storeValueParameter(name)(data, curr);\n  };\n};\n\nconst addTZ = function (dt, parameters) {\n  const p = parseParameters(parameters);\n\n  if (dt.tz) {\n    // Date already has a timezone property\n    return dt;\n  }\n\n  if (parameters && p && dt) {\n    dt.tz = p.TZID;\n    if (dt.tz !== undefined) {\n      // Remove surrounding quotes if found at the beginning and at the end of the string\n      // (Occurs when parsing Microsoft Exchange events containing TZID with Windows standard format instead IANA)\n      dt.tz = dt.tz.replace(/^\"(.*)\"$/, '$1');\n    }\n  }\n\n  return dt;\n};\n\nlet zoneTable = null;\nfunction getIanaTZFromMS(msTZName) {\n  if (!zoneTable) {\n    zoneTable = __webpack_require__(/*! ./windowsZones.json */ \"(ssr)/./node_modules/node-ical/windowsZones.json\");\n  }\n\n  // Get hash entry\n  const he = zoneTable[msTZName];\n  // If found return iana name, else null\n  return he ? he.iana[0] : null;\n}\n\nfunction getTimeZone(value) {\n  let tz = value;\n  let found = '';\n  // If this is the custom timezone from MS Outlook\n  if (tz === 'tzone://Microsoft/Custom' || tz.startsWith('Customized Time Zone') || tz.startsWith('tzone://Microsoft/')) {\n    // Set it to the local timezone, because we can't tell\n    tz = moment.tz.guess();\n  }\n\n  // Remove quotes if found\n  tz = tz.replace(/^\"(.*)\"$/, '$1');\n\n  // Watch out for windows timezones\n  if (tz && tz.includes(' ')) {\n    const tz1 = getIanaTZFromMS(tz);\n    if (tz1) {\n      tz = tz1;\n    }\n  }\n\n  // Watch out for offset timezones\n  // If the conversion above didn't find any matching IANA tz\n  // And offset is still present\n  if (tz && tz.startsWith('(')) {\n    // Extract just the offset\n    const regex = /[+|-]\\d*:\\d*/;\n    tz = null;\n    found = tz.match(regex);\n  }\n\n  // Timezone not confirmed yet\n  if (found === '') {\n    // Lookup tz\n    found = moment.tz.names().find(zone => {\n      return zone === tz;\n    });\n  }\n\n  return found === '' ? tz : found;\n}\n\nfunction isDateOnly(value, parameters) {\n  const dateOnly = ((parameters && parameters.includes('VALUE=DATE') && !parameters.includes('VALUE=DATE-TIME')) || /^\\d{8}$/.test(value) === true);\n  return dateOnly;\n}\n\nconst typeParameter = function (name) {\n  // Typename is not used in this function?\n  return function (value, parameters, curr) {\n    const returnValue = isDateOnly(value, parameters) ? 'date' : 'date-time';\n    return storeValueParameter(name)(returnValue, curr);\n  };\n};\n\nconst dateParameter = function (name) {\n  return function (value, parameters, curr, stack) {\n    // The regex from main gets confused by extra :\n    const pi = parameters.indexOf('TZID=tzone');\n    if (pi >= 0) {\n      // Correct the parameters with the part on the value\n      parameters[pi] = parameters[pi] + ':' + value.split(':')[0];\n      // Get the date from the field, other code uses the value parameter\n      value = value.split(':')[1];\n    }\n\n    let newDate = text(value);\n\n    // Process 'VALUE=DATE' and EXDATE\n    if (isDateOnly(value, parameters)) {\n      // Just Date\n\n      const comps = /^(\\d{4})(\\d{2})(\\d{2}).*$/.exec(value);\n      if (comps !== null) {\n        // No TZ info - assume same timezone as this computer\n        newDate = new Date(comps[1], Number.parseInt(comps[2], 10) - 1, comps[3]);\n\n        newDate.dateOnly = true;\n\n        // Store as string - worst case scenario\n        return storeValueParameter(name)(newDate, curr);\n      }\n    }\n\n    // Typical RFC date-time format\n    const comps = /^(\\d{4})(\\d{2})(\\d{2})T(\\d{2})(\\d{2})(\\d{2})(Z)?$/.exec(value);\n    if (comps !== null) {\n      if (comps[7] === 'Z') {\n        // GMT\n        newDate = new Date(\n          Date.UTC(\n            Number.parseInt(comps[1], 10),\n            Number.parseInt(comps[2], 10) - 1,\n            Number.parseInt(comps[3], 10),\n            Number.parseInt(comps[4], 10),\n            Number.parseInt(comps[5], 10),\n            Number.parseInt(comps[6], 10)\n          )\n        );\n        newDate.tz = 'Etc/UTC';\n      } else if (parameters && parameters[0] && parameters[0].includes('TZID=') && parameters[0].split('=')[1]) {\n        // Get the timezone from the parameters TZID value\n        let tz = parameters[0].split('=')[1];\n        let found = '';\n        let offset = '';\n\n        // If this is the custom timezone from MS Outlook\n        if (tz === 'tzone://Microsoft/Custom' || tz === '(no TZ description)' || tz.startsWith('Customized Time Zone') || tz.startsWith('tzone://Microsoft/')) {\n          // Set it to the local timezone, because we can't tell\n          tz = moment.tz.guess();\n          parameters[0] = 'TZID=' + tz;\n        }\n\n        // Remove quotes if found\n        tz = tz.replace(/^\"(.*)\"$/, '$1');\n\n        // Watch out for windows timezones\n        if (tz && tz.includes(' ')) {\n          const tz1 = getIanaTZFromMS(tz);\n          if (tz1) {\n            tz = tz1;\n            // We have a confirmed timezone, don't use offset, may confuse DST/STD time\n            offset = '';\n          }\n        }\n\n        // Watch out for offset timezones\n        // If the conversion above didn't find any matching IANA tz\n        // And offset is still present\n        if (tz && tz.startsWith('(')) {\n          // Extract just the offset\n          const regex = /[+|-]\\d*:\\d*/;\n          offset = tz.match(regex);\n          tz = null;\n          found = offset;\n        }\n\n        // Timezone not confirmed yet\n        if (found === '') {\n          // Lookup tz\n          found = moment.tz.names().find(zone => {\n            return zone === tz;\n          });\n        }\n\n        // Timezone confirmed or forced to offset\n        newDate = found ? moment.tz(value, 'YYYYMMDDTHHmmss' + offset, tz).toDate() : new Date(\n          Number.parseInt(comps[1], 10),\n          Number.parseInt(comps[2], 10) - 1,\n          Number.parseInt(comps[3], 10),\n          Number.parseInt(comps[4], 10),\n          Number.parseInt(comps[5], 10),\n          Number.parseInt(comps[6], 10)\n        );\n\n        newDate = addTZ(newDate, parameters);\n      } else {\n        // Get the time zone from the stack\n        const stackItemWithTimeZone =\n          (stack || []).find(item => {\n            return Object.values(item).find(subItem => subItem.type === 'VTIMEZONE');\n          }) || {};\n        const vTimezone =\n          Object.values(stackItemWithTimeZone).find(({type}) => type === 'VTIMEZONE');\n\n        newDate = vTimezone && moment.tz.zone(vTimezone.tzid) ?\n          moment.tz(value, 'YYYYMMDDTHHmmss', vTimezone.tzid).toDate() :\n          new Date(\n            Number.parseInt(comps[1], 10),\n            Number.parseInt(comps[2], 10) - 1,\n            Number.parseInt(comps[3], 10),\n            Number.parseInt(comps[4], 10),\n            Number.parseInt(comps[5], 10),\n            Number.parseInt(comps[6], 10)\n          );\n      }\n    }\n\n    // Store as string - worst case scenario\n    return storeValueParameter(name)(newDate, curr);\n  };\n};\n\nconst geoParameter = function (name) {\n  return function (value, parameters, curr) {\n    storeParameter(value, parameters, curr);\n    const parts = value.split(';');\n    curr[name] = {lat: Number(parts[0]), lon: Number(parts[1])};\n    return curr;\n  };\n};\n\nconst categoriesParameter = function (name) {\n  const separatorPattern = /\\s*,\\s*/g;\n  return function (value, parameters, curr) {\n    storeParameter(value, parameters, curr);\n    if (curr[name] === undefined) {\n      curr[name] = value ? value.split(separatorPattern) : [];\n    } else if (value) {\n      curr[name] = curr[name].concat(value.split(separatorPattern));\n    }\n\n    return curr;\n  };\n};\n\n// EXDATE is an entry that represents exceptions to a recurrence rule (ex: \"repeat every day except on 7/4\").\n// The EXDATE entry itself can also contain a comma-separated list, so we make sure to parse each date out separately.\n// There can also be more than one EXDATE entries in a calendar record.\n// Since there can be multiple dates, we create an array of them.  The index into the array is the ISO string of the date itself, for ease of use.\n// i.e. You can check if ((curr.exdate != undefined) && (curr.exdate[date iso string] != undefined)) to see if a date is an exception.\n// NOTE: This specifically uses date only, and not time.  This is to avoid a few problems:\n//    1. The ISO string with time wouldn't work for \"floating dates\" (dates without timezones).\n//       ex: \"20171225T060000\" - this is supposed to mean 6 AM in whatever timezone you're currently in\n//    2. Daylight savings time potentially affects the time you would need to look up\n//    3. Some EXDATE entries in the wild seem to have times different from the recurrence rule, but are still excluded by calendar programs.  Not sure how or why.\n//       These would fail any sort of sane time lookup, because the time literally doesn't match the event.  So we'll ignore time and just use date.\n//       ex: DTSTART:20170814T140000Z\n//             RRULE:FREQ=WEEKLY;WKST=SU;INTERVAL=2;BYDAY=MO,TU\n//             EXDATE:20171219T060000\n//       Even though \"T060000\" doesn't match or overlap \"T1400000Z\", it's still supposed to be excluded?  Odd. :(\n// TODO: See if this causes any problems with events that recur multiple times a day.\nconst exdateParameter = function (name) {\n  return function (value, parameters, curr) {\n    const separatorPattern = /\\s*,\\s*/g;\n    curr[name] = curr[name] || [];\n    const dates = value ? value.split(separatorPattern) : [];\n    for (const entry of dates) {\n      const exdate = [];\n      dateParameter(name)(entry, parameters, exdate);\n\n      if (exdate[name]) {\n        if (typeof exdate[name].toISOString === 'function') {\n          curr[name][exdate[name].toISOString().slice(0, 10)] = exdate[name];\n        } else {\n          throw new TypeError('No toISOString function in exdate[name]', exdate[name]);\n        }\n      }\n    }\n\n    return curr;\n  };\n};\n\n// RECURRENCE-ID is the ID of a specific recurrence within a recurrence rule.\n// TODO:  It's also possible for it to have a range, like \"THISANDPRIOR\", \"THISANDFUTURE\".  This isn't currently handled.\nconst recurrenceParameter = function (name) {\n  return dateParameter(name);\n};\n\nconst addFBType = function (fb, parameters) {\n  const p = parseParameters(parameters);\n\n  if (parameters && p) {\n    fb.type = p.FBTYPE || 'BUSY';\n  }\n\n  return fb;\n};\n\nconst freebusyParameter = function (name) {\n  return function (value, parameters, curr) {\n    const fb = addFBType({}, parameters);\n    curr[name] = curr[name] || [];\n    curr[name].push(fb);\n\n    storeParameter(value, parameters, fb);\n\n    const parts = value.split('/');\n\n    for (const [index, name] of ['start', 'end'].entries()) {\n      dateParameter(name)(parts[index], parameters, fb);\n    }\n\n    return curr;\n  };\n};\n\nmodule.exports = {\n  objectHandlers: {\n    BEGIN(component, parameters, curr, stack) {\n      stack.push(curr);\n\n      return {type: component, params: parameters};\n    },\n    END(value, parameters, curr, stack) {\n      // Original end function\n      const originalEnd = function (component, parameters_, curr, stack) {\n        // Prevents the need to search the root of the tree for the VCALENDAR object\n        if (component === 'VCALENDAR') {\n          // Scan all high level object in curr and drop all strings\n          let key;\n          let object;\n          const highLevel = {};\n\n          for (key in curr) {\n            if (!{}.hasOwnProperty.call(curr, key)) {\n              continue;\n            }\n\n            object = curr[key];\n            if (typeof object === 'string') {\n              highLevel[key] = object;\n              delete curr[key];\n            }\n          }\n\n          if (highLevel.type) {\n            curr[highLevel.type.toLowerCase()] = highLevel;\n          }\n\n          return curr;\n        }\n\n        const par = stack.pop();\n\n        if (!curr.end) { // RFC5545, 3.6.1\n          if (curr.datetype === 'date-time') {\n            curr.end = new Date(curr.start.getTime());\n            // If the duration is not set\n          } else if (curr.duration === undefined) {\n            // Set the end to the start plus one day RFC5545, 3.6.1\n            curr.end = moment.utc(curr.start).add(1, 'days').toDate(); // New Date(moment(curr.start).add(1, 'days'));\n          } else {\n            const durationUnits =\n              {\n                // Y: 'years',\n                // M: 'months',\n                W: 'weeks',\n                D: 'days',\n                H: 'hours',\n                M: 'minutes',\n                S: 'seconds'\n              };\n            // Get the list of duration elements\n            const r = curr.duration.match(/-?\\d+[YMWDHS]/g);\n            let newend = moment.utc(curr.start);\n            // Is the 1st character a negative sign?\n            const indicator = curr.duration.startsWith('-') ? -1 : 1;\n            // Process each element\n            for (const d of r) {\n              newend = newend.add(Number.parseInt(d, 10) * indicator, durationUnits[d.slice(-1)]);\n            }\n\n            curr.end = newend.toDate();\n          }\n        }\n\n        if (curr.uid) {\n          // If this is the first time we run into this UID, just save it.\n          if (par[curr.uid] === undefined) {\n            par[curr.uid] = curr;\n\n            if (par.method) { // RFC5545, 3.2\n              par[curr.uid].method = par.method;\n            }\n          } else if (curr.recurrenceid === undefined) {\n            // If we have multiple ical entries with the same UID, it's either going to be a\n            // modification to a recurrence (RECURRENCE-ID), and/or a significant modification\n            // to the entry (SEQUENCE).\n\n            // TODO: Look into proper sequence logic.\n\n            // If we have the same UID as an existing record, and it *isn't* a specific recurrence ID,\n            // not quite sure what the correct behaviour should be.  For now, just take the new information\n            // and merge it with the old record by overwriting only the fields that appear in the new record.\n            let key;\n            for (key in curr) {\n              if (key !== null) {\n                par[curr.uid][key] = curr[key];\n              }\n            }\n          }\n\n          // If we have recurrence-id entries, list them as an array of recurrences keyed off of recurrence-id.\n          // To use - as you're running through the dates of an rrule, you can try looking it up in the recurrences\n          // array.  If it exists, then use the data from the calendar object in the recurrence instead of the parent\n          // for that day.\n\n          // NOTE:  Sometimes the RECURRENCE-ID record will show up *before* the record with the RRULE entry.  In that\n          // case, what happens is that the RECURRENCE-ID record ends up becoming both the parent record and an entry\n          // in the recurrences array, and then when we process the RRULE entry later it overwrites the appropriate\n          // fields in the parent record.\n\n          if (typeof curr.recurrenceid !== 'undefined') {\n            // TODO:  Is there ever a case where we have to worry about overwriting an existing entry here?\n\n            // Create a copy of the current object to save in our recurrences array.  (We *could* just do par = curr,\n            // except for the case that we get the RECURRENCE-ID record before the RRULE record.  In that case, we\n            // would end up with a shared reference that would cause us to overwrite *both* records at the point\n            // that we try and fix up the parent record.)\n            const recurrenceObject = {};\n            let key;\n            for (key in curr) {\n              if (key !== null) {\n                recurrenceObject[key] = curr[key];\n              }\n            }\n\n            if (typeof recurrenceObject.recurrences !== 'undefined') {\n              delete recurrenceObject.recurrences;\n            }\n\n            // If we don't have an array to store recurrences in yet, create it.\n            if (par[curr.uid].recurrences === undefined) {\n              par[curr.uid].recurrences = {};\n            }\n\n            // Save off our cloned recurrence object into the array, keyed by date but not time.\n            // We key by date only to avoid timezone and \"floating time\" problems (where the time isn't associated with a timezone).\n            // TODO: See if this causes a problem with events that have multiple recurrences per day.\n            if (typeof curr.recurrenceid.toISOString === 'function') {\n              par[curr.uid].recurrences[curr.recurrenceid.toISOString().slice(0, 10)] = recurrenceObject;\n            } else { // Removed issue 56\n              throw new TypeError('No toISOString function in curr.recurrenceid', curr.recurrenceid);\n            }\n          }\n\n          // One more specific fix - in the case that an RRULE entry shows up after a RECURRENCE-ID entry,\n          // let's make sure to clear the recurrenceid off the parent field.\n          if (typeof par[curr.uid].rrule !== 'undefined' && typeof par[curr.uid].recurrenceid !== 'undefined') {\n            delete par[curr.uid].recurrenceid;\n          }\n        } else {\n          const id = uuid();\n          par[id] = curr;\n\n          if (par.method) { // RFC5545, 3.2\n            par[id].method = par.method;\n          }\n        }\n\n        return par;\n      };\n\n      // Recurrence rules are only valid for VEVENT, VTODO, and VJOURNAL.\n      // More specifically, we need to filter the VCALENDAR type because we might end up with a defined rrule\n      // due to the subtypes.\n\n      if ((value === 'VEVENT' || value === 'VTODO' || value === 'VJOURNAL') && curr.rrule) {\n        let rule = curr.rrule.replace('RRULE:', '');\n        // Make sure the rrule starts with FREQ=\n        rule = rule.slice(rule.lastIndexOf('FREQ='));\n        // If no rule start date\n        if (rule.includes('DTSTART') === false) {\n          // Get date/time into a specific format for comapare\n          let x = moment(curr.start).format('MMMM/Do/YYYY, h:mm:ss a');\n          // If the local time value is midnight\n          // This a whole day event\n          if (x.slice(-11) === '12:00:00 am') {\n            // Get the timezone offset\n            // The internal date is stored in UTC format\n            const offset = curr.start.getTimezoneOffset();\n            // Only east of gmt is a problem\n            if (offset < 0) {\n              // Calculate the new startdate with the offset applied, bypass RRULE/Luxon confusion\n              // Make the internally stored DATE the actual date (not UTC offseted)\n              // Luxon expects local time, not utc, so gets start date wrong if not adjusted\n              curr.start = new Date(curr.start.getTime() + (Math.abs(offset) * 60000));\n            } else {\n              // Get rid of any time (shouldn't be any, but be sure)\n              x = moment(curr.start).format('MMMM/Do/YYYY');\n              const comps = /^(\\d{2})\\/(\\d{2})\\/(\\d{4})/.exec(x);\n              if (comps) {\n                curr.start = new Date(comps[3], comps[1] - 1, comps[2]);\n              }\n            }\n          }\n\n          // If the date has an toISOString function\n          if (curr.start && typeof curr.start.toISOString === 'function') {\n            try {\n              // If the original date has a TZID, add it\n              if (curr.start.tz) {\n                const tz = getTimeZone(curr.start.tz);\n                rule += `;DTSTART;TZID=${tz}:${curr.start.toISOString().replace(/[-:]/g, '')}`;\n              } else {\n                rule += `;DTSTART=${curr.start.toISOString().replace(/[-:]/g, '')}`;\n              }\n\n              rule = rule.replace(/\\.\\d{3}/, '');\n            } catch (error) { // This should not happen, issue #56\n              throw new Error('ERROR when trying to convert to ISOString', error);\n            }\n          } else {\n            throw new Error('No toISOString function in curr.start', curr.start);\n          }\n        }\n\n        // Make sure to catch error from rrule.fromString()\n        try {\n          curr.rrule = rrule.fromString(rule);\n        } catch (error) {\n          throw error;\n        }\n      }\n\n      return originalEnd.call(this, value, parameters, curr, stack);\n    },\n    SUMMARY: storeParameter('summary'),\n    DESCRIPTION: storeParameter('description'),\n    URL: storeParameter('url'),\n    UID: storeParameter('uid'),\n    LOCATION: storeParameter('location'),\n    DTSTART(value, parameters, curr, stack) {\n      curr = dateParameter('start')(value, parameters, curr, stack);\n      return typeParameter('datetype')(value, parameters, curr);\n    },\n    DTEND: dateParameter('end'),\n    EXDATE: exdateParameter('exdate'),\n    ' CLASS': storeParameter('class'), // Should there be a space in this property?\n    TRANSP: storeParameter('transparency'),\n    GEO: geoParameter('geo'),\n    'PERCENT-COMPLETE': storeParameter('completion'),\n    COMPLETED: dateParameter('completed'),\n    CATEGORIES: categoriesParameter('categories'),\n    FREEBUSY: freebusyParameter('freebusy'),\n    DTSTAMP: dateParameter('dtstamp'),\n    CREATED: dateParameter('created'),\n    'LAST-MODIFIED': dateParameter('lastmodified'),\n    'RECURRENCE-ID': recurrenceParameter('recurrenceid'),\n    RRULE(value, parameters, curr, stack, line) {\n      curr.rrule = line;\n      return curr;\n    }\n  },\n\n  handleObject(name, value, parameters, ctx, stack, line) {\n    if (this.objectHandlers[name]) {\n      return this.objectHandlers[name](value, parameters, ctx, stack, line);\n    }\n\n    // Handling custom properties\n    if (/X-[\\w-]+/.test(name) && stack.length > 0) {\n      // Trimming the leading and perform storeParam\n      name = name.slice(2);\n      return storeParameter(name)(value, parameters, ctx, stack, line);\n    }\n\n    return storeParameter(name.toLowerCase())(value, parameters, ctx);\n  },\n\n  parseLines(lines, limit, ctx, stack, lastIndex, cb) {\n    if (!cb && typeof ctx === 'function') {\n      cb = ctx;\n      ctx = undefined;\n    }\n\n    ctx = ctx || {};\n    stack = stack || [];\n\n    let limitCounter = 0;\n\n    let i = lastIndex || 0;\n    for (let ii = lines.length; i < ii; i++) {\n      let l = lines[i];\n      // Unfold : RFC#3.1\n      while (lines[i + 1] && /[ \\t]/.test(lines[i + 1][0])) {\n        l += lines[i + 1].slice(1);\n        i++;\n      }\n\n      // Remove any double quotes in any tzid statement// except around (utc+hh:mm\n      if (l.indexOf('TZID=') && !l.includes('\"(')) {\n        l = l.replace(/\"/g, '');\n      }\n\n      const exp = /^([\\w\\d-]+)((?:;[\\w\\d-]+=(?:(?:\"[^\"]*\")|[^\":;]+))*):(.*)$/;\n      let kv = l.match(exp);\n\n      if (kv === null) {\n        // Invalid line - must have k&v\n        continue;\n      }\n\n      kv = kv.slice(1);\n\n      const value = kv[kv.length - 1];\n      const name = kv[0];\n      const parameters = kv[1] ? kv[1].split(';').slice(1) : [];\n\n      ctx = this.handleObject(name, value, parameters, ctx, stack, l) || {};\n      if (++limitCounter > limit) {\n        break;\n      }\n    }\n\n    if (i >= lines.length) {\n      // Type and params are added to the list of items, get rid of them.\n      delete ctx.type;\n      delete ctx.params;\n    }\n\n    if (cb) {\n      if (i < lines.length) {\n        setImmediate(() => {\n          this.parseLines(lines, limit, ctx, stack, i + 1, cb);\n        });\n      } else {\n        setImmediate(() => {\n          cb(null, ctx);\n        });\n      }\n    } else {\n      return ctx;\n    }\n  },\n\n  parseICS(string, cb) {\n    const lines = string.split(/\\r?\\n/);\n    let ctx;\n\n    if (cb) {\n      // Asynchronous execution\n      this.parseLines(lines, 2000, cb);\n    } else {\n      // Synchronous execution\n      ctx = this.parseLines(lines, lines.length);\n      return ctx;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1pY2FsL2ljYWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsT0FBTyxVQUFVLEVBQUUsbUJBQU8sQ0FBQyw4REFBTTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsc0VBQWlCO0FBQ3hDLGNBQWMsd0ZBQXNCOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0pBQStKLHVEQUF1RDs7QUFFdE47QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDZFQUFxQjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUhBQXlILEVBQUU7QUFDM0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esc0RBQXNELEtBQUs7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVEsV0FBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSx1RUFBdUU7QUFDdkUsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxrQ0FBa0MsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVEsT0FBTyxHQUFHLEdBQUcsOENBQThDO0FBQzdGLGdCQUFnQjtBQUNoQiwwQkFBMEIsVUFBVSw4Q0FBOEM7QUFDbEY7O0FBRUEsd0NBQXdDLEVBQUU7QUFDMUMsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyw2QkFBNkI7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVzdC8uL25vZGVfbW9kdWxlcy9ub2RlLWljYWwvaWNhbC5qcz85M2VhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCwgbWF4LXBhcmFtcywgbm8td2FybmluZy1jb21tZW50cywgY29tcGxleGl0eSAqL1xuXG5jb25zdCB7djQ6IHV1aWR9ID0gcmVxdWlyZSgndXVpZCcpO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50LXRpbWV6b25lJyk7XG5jb25zdCBycnVsZSA9IHJlcXVpcmUoJ3JydWxlJykuUlJ1bGU7XG5cbi8qKiAqKioqKioqKioqKioqKlxuICogIEEgdG9sZXJhbnQsIG1pbmltYWwgaWNhbGVuZGFyIHBhcnNlclxuICogIChodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1NTQ1KVxuICpcbiAqICA8cGV0ZXJicmFkZW5AcGV0ZXJicmFkZW4uY28udWs+XG4gKiAqKioqKioqKioqKioqICovXG5cbi8vIFVuZXNjYXBlIFRleHQgcmUgUkZDIDQuMy4xMVxuY29uc3QgdGV4dCA9IGZ1bmN0aW9uICh0ID0gJycpIHtcbiAgcmV0dXJuIHRcbiAgICAucmVwbGFjZSgvXFxcXCwvZywgJywnKVxuICAgIC5yZXBsYWNlKC9cXFxcOy9nLCAnOycpXG4gICAgLnJlcGxhY2UoL1xcXFxbbk5dL2csICdcXG4nKVxuICAgIC5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xufTtcblxuY29uc3QgcGFyc2VWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09ICdUUlVFJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSAnRkFMU0UnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgbnVtYmVyID0gTnVtYmVyKHZhbHVlKTtcbiAgaWYgKCFOdW1iZXIuaXNOYU4obnVtYmVyKSkge1xuICAgIHJldHVybiBudW1iZXI7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5jb25zdCBwYXJzZVBhcmFtZXRlcnMgPSBmdW5jdGlvbiAocCkge1xuICBjb25zdCBvdXQgPSB7fTtcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIHApIHtcbiAgICBpZiAoZWxlbWVudC5pbmNsdWRlcygnPScpKSB7XG4gICAgICBjb25zdCBzZWdzID0gZWxlbWVudC5zcGxpdCgnPScpO1xuXG4gICAgICBvdXRbc2Vnc1swXV0gPSBwYXJzZVZhbHVlKHNlZ3Muc2xpY2UoMSkuam9pbignPScpKTtcbiAgICB9XG4gIH1cblxuICAvLyBTcCBpcyBub3QgZGVmaW5lZCBpbiB0aGlzIHNjb3BlLCB0eXBvP1xuICAvLyBvcmlnaW5hbCBjb2RlIGZyb20gcGV0ZXJicmFkZW5cbiAgLy8gcmV0dXJuIG91dCB8fCBzcDtcbiAgcmV0dXJuIG91dDtcbn07XG5cbmNvbnN0IHN0b3JlVmFsdWVQYXJhbWV0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBjdXJyKSB7XG4gICAgY29uc3QgY3VycmVudCA9IGN1cnJbbmFtZV07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgICAgY3VycmVudC5wdXNoKHZhbHVlKTtcbiAgICAgIHJldHVybiBjdXJyO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY3VycmVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGN1cnJbbmFtZV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycltuYW1lXSA9IFtjdXJyZW50LCB2YWx1ZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnI7XG4gIH07XG59O1xuXG5jb25zdCBzdG9yZVBhcmFtZXRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIHBhcmFtZXRlcnMsIGN1cnIpIHtcbiAgICBjb25zdCBkYXRhID0gcGFyYW1ldGVycyAmJiBwYXJhbWV0ZXJzLmxlbmd0aCA+IDAgJiYgIShwYXJhbWV0ZXJzLmxlbmd0aCA9PT0gMSAmJiAocGFyYW1ldGVyc1swXSA9PT0gJ0NIQVJTRVQ9dXRmLTgnIHx8IHBhcmFtZXRlcnNbMF0gPT09ICdWQUxVRT1URVhUJykpID8ge3BhcmFtczogcGFyc2VQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpLCB2YWw6IHRleHQodmFsdWUpfSA6IHRleHQodmFsdWUpO1xuXG4gICAgcmV0dXJuIHN0b3JlVmFsdWVQYXJhbWV0ZXIobmFtZSkoZGF0YSwgY3Vycik7XG4gIH07XG59O1xuXG5jb25zdCBhZGRUWiA9IGZ1bmN0aW9uIChkdCwgcGFyYW1ldGVycykge1xuICBjb25zdCBwID0gcGFyc2VQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuXG4gIGlmIChkdC50eikge1xuICAgIC8vIERhdGUgYWxyZWFkeSBoYXMgYSB0aW1lem9uZSBwcm9wZXJ0eVxuICAgIHJldHVybiBkdDtcbiAgfVxuXG4gIGlmIChwYXJhbWV0ZXJzICYmIHAgJiYgZHQpIHtcbiAgICBkdC50eiA9IHAuVFpJRDtcbiAgICBpZiAoZHQudHogIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gUmVtb3ZlIHN1cnJvdW5kaW5nIHF1b3RlcyBpZiBmb3VuZCBhdCB0aGUgYmVnaW5uaW5nIGFuZCBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmdcbiAgICAgIC8vIChPY2N1cnMgd2hlbiBwYXJzaW5nIE1pY3Jvc29mdCBFeGNoYW5nZSBldmVudHMgY29udGFpbmluZyBUWklEIHdpdGggV2luZG93cyBzdGFuZGFyZCBmb3JtYXQgaW5zdGVhZCBJQU5BKVxuICAgICAgZHQudHogPSBkdC50ei5yZXBsYWNlKC9eXCIoLiopXCIkLywgJyQxJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGR0O1xufTtcblxubGV0IHpvbmVUYWJsZSA9IG51bGw7XG5mdW5jdGlvbiBnZXRJYW5hVFpGcm9tTVMobXNUWk5hbWUpIHtcbiAgaWYgKCF6b25lVGFibGUpIHtcbiAgICB6b25lVGFibGUgPSByZXF1aXJlKCcuL3dpbmRvd3Nab25lcy5qc29uJyk7XG4gIH1cblxuICAvLyBHZXQgaGFzaCBlbnRyeVxuICBjb25zdCBoZSA9IHpvbmVUYWJsZVttc1RaTmFtZV07XG4gIC8vIElmIGZvdW5kIHJldHVybiBpYW5hIG5hbWUsIGVsc2UgbnVsbFxuICByZXR1cm4gaGUgPyBoZS5pYW5hWzBdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VGltZVpvbmUodmFsdWUpIHtcbiAgbGV0IHR6ID0gdmFsdWU7XG4gIGxldCBmb3VuZCA9ICcnO1xuICAvLyBJZiB0aGlzIGlzIHRoZSBjdXN0b20gdGltZXpvbmUgZnJvbSBNUyBPdXRsb29rXG4gIGlmICh0eiA9PT0gJ3R6b25lOi8vTWljcm9zb2Z0L0N1c3RvbScgfHwgdHouc3RhcnRzV2l0aCgnQ3VzdG9taXplZCBUaW1lIFpvbmUnKSB8fCB0ei5zdGFydHNXaXRoKCd0em9uZTovL01pY3Jvc29mdC8nKSkge1xuICAgIC8vIFNldCBpdCB0byB0aGUgbG9jYWwgdGltZXpvbmUsIGJlY2F1c2Ugd2UgY2FuJ3QgdGVsbFxuICAgIHR6ID0gbW9tZW50LnR6Lmd1ZXNzKCk7XG4gIH1cblxuICAvLyBSZW1vdmUgcXVvdGVzIGlmIGZvdW5kXG4gIHR6ID0gdHoucmVwbGFjZSgvXlwiKC4qKVwiJC8sICckMScpO1xuXG4gIC8vIFdhdGNoIG91dCBmb3Igd2luZG93cyB0aW1lem9uZXNcbiAgaWYgKHR6ICYmIHR6LmluY2x1ZGVzKCcgJykpIHtcbiAgICBjb25zdCB0ejEgPSBnZXRJYW5hVFpGcm9tTVModHopO1xuICAgIGlmICh0ejEpIHtcbiAgICAgIHR6ID0gdHoxO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdhdGNoIG91dCBmb3Igb2Zmc2V0IHRpbWV6b25lc1xuICAvLyBJZiB0aGUgY29udmVyc2lvbiBhYm92ZSBkaWRuJ3QgZmluZCBhbnkgbWF0Y2hpbmcgSUFOQSB0elxuICAvLyBBbmQgb2Zmc2V0IGlzIHN0aWxsIHByZXNlbnRcbiAgaWYgKHR6ICYmIHR6LnN0YXJ0c1dpdGgoJygnKSkge1xuICAgIC8vIEV4dHJhY3QganVzdCB0aGUgb2Zmc2V0XG4gICAgY29uc3QgcmVnZXggPSAvWyt8LV1cXGQqOlxcZCovO1xuICAgIHR6ID0gbnVsbDtcbiAgICBmb3VuZCA9IHR6Lm1hdGNoKHJlZ2V4KTtcbiAgfVxuXG4gIC8vIFRpbWV6b25lIG5vdCBjb25maXJtZWQgeWV0XG4gIGlmIChmb3VuZCA9PT0gJycpIHtcbiAgICAvLyBMb29rdXAgdHpcbiAgICBmb3VuZCA9IG1vbWVudC50ei5uYW1lcygpLmZpbmQoem9uZSA9PiB7XG4gICAgICByZXR1cm4gem9uZSA9PT0gdHo7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZm91bmQgPT09ICcnID8gdHogOiBmb3VuZDtcbn1cblxuZnVuY3Rpb24gaXNEYXRlT25seSh2YWx1ZSwgcGFyYW1ldGVycykge1xuICBjb25zdCBkYXRlT25seSA9ICgocGFyYW1ldGVycyAmJiBwYXJhbWV0ZXJzLmluY2x1ZGVzKCdWQUxVRT1EQVRFJykgJiYgIXBhcmFtZXRlcnMuaW5jbHVkZXMoJ1ZBTFVFPURBVEUtVElNRScpKSB8fCAvXlxcZHs4fSQvLnRlc3QodmFsdWUpID09PSB0cnVlKTtcbiAgcmV0dXJuIGRhdGVPbmx5O1xufVxuXG5jb25zdCB0eXBlUGFyYW1ldGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgLy8gVHlwZW5hbWUgaXMgbm90IHVzZWQgaW4gdGhpcyBmdW5jdGlvbj9cbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgcGFyYW1ldGVycywgY3Vycikge1xuICAgIGNvbnN0IHJldHVyblZhbHVlID0gaXNEYXRlT25seSh2YWx1ZSwgcGFyYW1ldGVycykgPyAnZGF0ZScgOiAnZGF0ZS10aW1lJztcbiAgICByZXR1cm4gc3RvcmVWYWx1ZVBhcmFtZXRlcihuYW1lKShyZXR1cm5WYWx1ZSwgY3Vycik7XG4gIH07XG59O1xuXG5jb25zdCBkYXRlUGFyYW1ldGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgcGFyYW1ldGVycywgY3Vyciwgc3RhY2spIHtcbiAgICAvLyBUaGUgcmVnZXggZnJvbSBtYWluIGdldHMgY29uZnVzZWQgYnkgZXh0cmEgOlxuICAgIGNvbnN0IHBpID0gcGFyYW1ldGVycy5pbmRleE9mKCdUWklEPXR6b25lJyk7XG4gICAgaWYgKHBpID49IDApIHtcbiAgICAgIC8vIENvcnJlY3QgdGhlIHBhcmFtZXRlcnMgd2l0aCB0aGUgcGFydCBvbiB0aGUgdmFsdWVcbiAgICAgIHBhcmFtZXRlcnNbcGldID0gcGFyYW1ldGVyc1twaV0gKyAnOicgKyB2YWx1ZS5zcGxpdCgnOicpWzBdO1xuICAgICAgLy8gR2V0IHRoZSBkYXRlIGZyb20gdGhlIGZpZWxkLCBvdGhlciBjb2RlIHVzZXMgdGhlIHZhbHVlIHBhcmFtZXRlclxuICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnOicpWzFdO1xuICAgIH1cblxuICAgIGxldCBuZXdEYXRlID0gdGV4dCh2YWx1ZSk7XG5cbiAgICAvLyBQcm9jZXNzICdWQUxVRT1EQVRFJyBhbmQgRVhEQVRFXG4gICAgaWYgKGlzRGF0ZU9ubHkodmFsdWUsIHBhcmFtZXRlcnMpKSB7XG4gICAgICAvLyBKdXN0IERhdGVcblxuICAgICAgY29uc3QgY29tcHMgPSAvXihcXGR7NH0pKFxcZHsyfSkoXFxkezJ9KS4qJC8uZXhlYyh2YWx1ZSk7XG4gICAgICBpZiAoY29tcHMgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTm8gVFogaW5mbyAtIGFzc3VtZSBzYW1lIHRpbWV6b25lIGFzIHRoaXMgY29tcHV0ZXJcbiAgICAgICAgbmV3RGF0ZSA9IG5ldyBEYXRlKGNvbXBzWzFdLCBOdW1iZXIucGFyc2VJbnQoY29tcHNbMl0sIDEwKSAtIDEsIGNvbXBzWzNdKTtcblxuICAgICAgICBuZXdEYXRlLmRhdGVPbmx5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBTdG9yZSBhcyBzdHJpbmcgLSB3b3JzdCBjYXNlIHNjZW5hcmlvXG4gICAgICAgIHJldHVybiBzdG9yZVZhbHVlUGFyYW1ldGVyKG5hbWUpKG5ld0RhdGUsIGN1cnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFR5cGljYWwgUkZDIGRhdGUtdGltZSBmb3JtYXRcbiAgICBjb25zdCBjb21wcyA9IC9eKFxcZHs0fSkoXFxkezJ9KShcXGR7Mn0pVChcXGR7Mn0pKFxcZHsyfSkoXFxkezJ9KShaKT8kLy5leGVjKHZhbHVlKTtcbiAgICBpZiAoY29tcHMgIT09IG51bGwpIHtcbiAgICAgIGlmIChjb21wc1s3XSA9PT0gJ1onKSB7XG4gICAgICAgIC8vIEdNVFxuICAgICAgICBuZXdEYXRlID0gbmV3IERhdGUoXG4gICAgICAgICAgRGF0ZS5VVEMoXG4gICAgICAgICAgICBOdW1iZXIucGFyc2VJbnQoY29tcHNbMV0sIDEwKSxcbiAgICAgICAgICAgIE51bWJlci5wYXJzZUludChjb21wc1syXSwgMTApIC0gMSxcbiAgICAgICAgICAgIE51bWJlci5wYXJzZUludChjb21wc1szXSwgMTApLFxuICAgICAgICAgICAgTnVtYmVyLnBhcnNlSW50KGNvbXBzWzRdLCAxMCksXG4gICAgICAgICAgICBOdW1iZXIucGFyc2VJbnQoY29tcHNbNV0sIDEwKSxcbiAgICAgICAgICAgIE51bWJlci5wYXJzZUludChjb21wc1s2XSwgMTApXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBuZXdEYXRlLnR6ID0gJ0V0Yy9VVEMnO1xuICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXJzICYmIHBhcmFtZXRlcnNbMF0gJiYgcGFyYW1ldGVyc1swXS5pbmNsdWRlcygnVFpJRD0nKSAmJiBwYXJhbWV0ZXJzWzBdLnNwbGl0KCc9JylbMV0pIHtcbiAgICAgICAgLy8gR2V0IHRoZSB0aW1lem9uZSBmcm9tIHRoZSBwYXJhbWV0ZXJzIFRaSUQgdmFsdWVcbiAgICAgICAgbGV0IHR6ID0gcGFyYW1ldGVyc1swXS5zcGxpdCgnPScpWzFdO1xuICAgICAgICBsZXQgZm91bmQgPSAnJztcbiAgICAgICAgbGV0IG9mZnNldCA9ICcnO1xuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGN1c3RvbSB0aW1lem9uZSBmcm9tIE1TIE91dGxvb2tcbiAgICAgICAgaWYgKHR6ID09PSAndHpvbmU6Ly9NaWNyb3NvZnQvQ3VzdG9tJyB8fCB0eiA9PT0gJyhubyBUWiBkZXNjcmlwdGlvbiknIHx8IHR6LnN0YXJ0c1dpdGgoJ0N1c3RvbWl6ZWQgVGltZSBab25lJykgfHwgdHouc3RhcnRzV2l0aCgndHpvbmU6Ly9NaWNyb3NvZnQvJykpIHtcbiAgICAgICAgICAvLyBTZXQgaXQgdG8gdGhlIGxvY2FsIHRpbWV6b25lLCBiZWNhdXNlIHdlIGNhbid0IHRlbGxcbiAgICAgICAgICB0eiA9IG1vbWVudC50ei5ndWVzcygpO1xuICAgICAgICAgIHBhcmFtZXRlcnNbMF0gPSAnVFpJRD0nICsgdHo7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgcXVvdGVzIGlmIGZvdW5kXG4gICAgICAgIHR6ID0gdHoucmVwbGFjZSgvXlwiKC4qKVwiJC8sICckMScpO1xuXG4gICAgICAgIC8vIFdhdGNoIG91dCBmb3Igd2luZG93cyB0aW1lem9uZXNcbiAgICAgICAgaWYgKHR6ICYmIHR6LmluY2x1ZGVzKCcgJykpIHtcbiAgICAgICAgICBjb25zdCB0ejEgPSBnZXRJYW5hVFpGcm9tTVModHopO1xuICAgICAgICAgIGlmICh0ejEpIHtcbiAgICAgICAgICAgIHR6ID0gdHoxO1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIGNvbmZpcm1lZCB0aW1lem9uZSwgZG9uJ3QgdXNlIG9mZnNldCwgbWF5IGNvbmZ1c2UgRFNUL1NURCB0aW1lXG4gICAgICAgICAgICBvZmZzZXQgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXYXRjaCBvdXQgZm9yIG9mZnNldCB0aW1lem9uZXNcbiAgICAgICAgLy8gSWYgdGhlIGNvbnZlcnNpb24gYWJvdmUgZGlkbid0IGZpbmQgYW55IG1hdGNoaW5nIElBTkEgdHpcbiAgICAgICAgLy8gQW5kIG9mZnNldCBpcyBzdGlsbCBwcmVzZW50XG4gICAgICAgIGlmICh0eiAmJiB0ei5zdGFydHNXaXRoKCcoJykpIHtcbiAgICAgICAgICAvLyBFeHRyYWN0IGp1c3QgdGhlIG9mZnNldFxuICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gL1srfC1dXFxkKjpcXGQqLztcbiAgICAgICAgICBvZmZzZXQgPSB0ei5tYXRjaChyZWdleCk7XG4gICAgICAgICAgdHogPSBudWxsO1xuICAgICAgICAgIGZvdW5kID0gb2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGltZXpvbmUgbm90IGNvbmZpcm1lZCB5ZXRcbiAgICAgICAgaWYgKGZvdW5kID09PSAnJykge1xuICAgICAgICAgIC8vIExvb2t1cCB0elxuICAgICAgICAgIGZvdW5kID0gbW9tZW50LnR6Lm5hbWVzKCkuZmluZCh6b25lID0+IHtcbiAgICAgICAgICAgIHJldHVybiB6b25lID09PSB0ejtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRpbWV6b25lIGNvbmZpcm1lZCBvciBmb3JjZWQgdG8gb2Zmc2V0XG4gICAgICAgIG5ld0RhdGUgPSBmb3VuZCA/IG1vbWVudC50eih2YWx1ZSwgJ1lZWVlNTUREVEhIbW1zcycgKyBvZmZzZXQsIHR6KS50b0RhdGUoKSA6IG5ldyBEYXRlKFxuICAgICAgICAgIE51bWJlci5wYXJzZUludChjb21wc1sxXSwgMTApLFxuICAgICAgICAgIE51bWJlci5wYXJzZUludChjb21wc1syXSwgMTApIC0gMSxcbiAgICAgICAgICBOdW1iZXIucGFyc2VJbnQoY29tcHNbM10sIDEwKSxcbiAgICAgICAgICBOdW1iZXIucGFyc2VJbnQoY29tcHNbNF0sIDEwKSxcbiAgICAgICAgICBOdW1iZXIucGFyc2VJbnQoY29tcHNbNV0sIDEwKSxcbiAgICAgICAgICBOdW1iZXIucGFyc2VJbnQoY29tcHNbNl0sIDEwKVxuICAgICAgICApO1xuXG4gICAgICAgIG5ld0RhdGUgPSBhZGRUWihuZXdEYXRlLCBwYXJhbWV0ZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEdldCB0aGUgdGltZSB6b25lIGZyb20gdGhlIHN0YWNrXG4gICAgICAgIGNvbnN0IHN0YWNrSXRlbVdpdGhUaW1lWm9uZSA9XG4gICAgICAgICAgKHN0YWNrIHx8IFtdKS5maW5kKGl0ZW0gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoaXRlbSkuZmluZChzdWJJdGVtID0+IHN1Ykl0ZW0udHlwZSA9PT0gJ1ZUSU1FWk9ORScpO1xuICAgICAgICAgIH0pIHx8IHt9O1xuICAgICAgICBjb25zdCB2VGltZXpvbmUgPVxuICAgICAgICAgIE9iamVjdC52YWx1ZXMoc3RhY2tJdGVtV2l0aFRpbWVab25lKS5maW5kKCh7dHlwZX0pID0+IHR5cGUgPT09ICdWVElNRVpPTkUnKTtcblxuICAgICAgICBuZXdEYXRlID0gdlRpbWV6b25lICYmIG1vbWVudC50ei56b25lKHZUaW1lem9uZS50emlkKSA/XG4gICAgICAgICAgbW9tZW50LnR6KHZhbHVlLCAnWVlZWU1NRERUSEhtbXNzJywgdlRpbWV6b25lLnR6aWQpLnRvRGF0ZSgpIDpcbiAgICAgICAgICBuZXcgRGF0ZShcbiAgICAgICAgICAgIE51bWJlci5wYXJzZUludChjb21wc1sxXSwgMTApLFxuICAgICAgICAgICAgTnVtYmVyLnBhcnNlSW50KGNvbXBzWzJdLCAxMCkgLSAxLFxuICAgICAgICAgICAgTnVtYmVyLnBhcnNlSW50KGNvbXBzWzNdLCAxMCksXG4gICAgICAgICAgICBOdW1iZXIucGFyc2VJbnQoY29tcHNbNF0sIDEwKSxcbiAgICAgICAgICAgIE51bWJlci5wYXJzZUludChjb21wc1s1XSwgMTApLFxuICAgICAgICAgICAgTnVtYmVyLnBhcnNlSW50KGNvbXBzWzZdLCAxMClcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0b3JlIGFzIHN0cmluZyAtIHdvcnN0IGNhc2Ugc2NlbmFyaW9cbiAgICByZXR1cm4gc3RvcmVWYWx1ZVBhcmFtZXRlcihuYW1lKShuZXdEYXRlLCBjdXJyKTtcbiAgfTtcbn07XG5cbmNvbnN0IGdlb1BhcmFtZXRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIHBhcmFtZXRlcnMsIGN1cnIpIHtcbiAgICBzdG9yZVBhcmFtZXRlcih2YWx1ZSwgcGFyYW1ldGVycywgY3Vycik7XG4gICAgY29uc3QgcGFydHMgPSB2YWx1ZS5zcGxpdCgnOycpO1xuICAgIGN1cnJbbmFtZV0gPSB7bGF0OiBOdW1iZXIocGFydHNbMF0pLCBsb246IE51bWJlcihwYXJ0c1sxXSl9O1xuICAgIHJldHVybiBjdXJyO1xuICB9O1xufTtcblxuY29uc3QgY2F0ZWdvcmllc1BhcmFtZXRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGNvbnN0IHNlcGFyYXRvclBhdHRlcm4gPSAvXFxzKixcXHMqL2c7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIHBhcmFtZXRlcnMsIGN1cnIpIHtcbiAgICBzdG9yZVBhcmFtZXRlcih2YWx1ZSwgcGFyYW1ldGVycywgY3Vycik7XG4gICAgaWYgKGN1cnJbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3VycltuYW1lXSA9IHZhbHVlID8gdmFsdWUuc3BsaXQoc2VwYXJhdG9yUGF0dGVybikgOiBbXTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICBjdXJyW25hbWVdID0gY3VycltuYW1lXS5jb25jYXQodmFsdWUuc3BsaXQoc2VwYXJhdG9yUGF0dGVybikpO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyO1xuICB9O1xufTtcblxuLy8gRVhEQVRFIGlzIGFuIGVudHJ5IHRoYXQgcmVwcmVzZW50cyBleGNlcHRpb25zIHRvIGEgcmVjdXJyZW5jZSBydWxlIChleDogXCJyZXBlYXQgZXZlcnkgZGF5IGV4Y2VwdCBvbiA3LzRcIikuXG4vLyBUaGUgRVhEQVRFIGVudHJ5IGl0c2VsZiBjYW4gYWxzbyBjb250YWluIGEgY29tbWEtc2VwYXJhdGVkIGxpc3QsIHNvIHdlIG1ha2Ugc3VyZSB0byBwYXJzZSBlYWNoIGRhdGUgb3V0IHNlcGFyYXRlbHkuXG4vLyBUaGVyZSBjYW4gYWxzbyBiZSBtb3JlIHRoYW4gb25lIEVYREFURSBlbnRyaWVzIGluIGEgY2FsZW5kYXIgcmVjb3JkLlxuLy8gU2luY2UgdGhlcmUgY2FuIGJlIG11bHRpcGxlIGRhdGVzLCB3ZSBjcmVhdGUgYW4gYXJyYXkgb2YgdGhlbS4gIFRoZSBpbmRleCBpbnRvIHRoZSBhcnJheSBpcyB0aGUgSVNPIHN0cmluZyBvZiB0aGUgZGF0ZSBpdHNlbGYsIGZvciBlYXNlIG9mIHVzZS5cbi8vIGkuZS4gWW91IGNhbiBjaGVjayBpZiAoKGN1cnIuZXhkYXRlICE9IHVuZGVmaW5lZCkgJiYgKGN1cnIuZXhkYXRlW2RhdGUgaXNvIHN0cmluZ10gIT0gdW5kZWZpbmVkKSkgdG8gc2VlIGlmIGEgZGF0ZSBpcyBhbiBleGNlcHRpb24uXG4vLyBOT1RFOiBUaGlzIHNwZWNpZmljYWxseSB1c2VzIGRhdGUgb25seSwgYW5kIG5vdCB0aW1lLiAgVGhpcyBpcyB0byBhdm9pZCBhIGZldyBwcm9ibGVtczpcbi8vICAgIDEuIFRoZSBJU08gc3RyaW5nIHdpdGggdGltZSB3b3VsZG4ndCB3b3JrIGZvciBcImZsb2F0aW5nIGRhdGVzXCIgKGRhdGVzIHdpdGhvdXQgdGltZXpvbmVzKS5cbi8vICAgICAgIGV4OiBcIjIwMTcxMjI1VDA2MDAwMFwiIC0gdGhpcyBpcyBzdXBwb3NlZCB0byBtZWFuIDYgQU0gaW4gd2hhdGV2ZXIgdGltZXpvbmUgeW91J3JlIGN1cnJlbnRseSBpblxuLy8gICAgMi4gRGF5bGlnaHQgc2F2aW5ncyB0aW1lIHBvdGVudGlhbGx5IGFmZmVjdHMgdGhlIHRpbWUgeW91IHdvdWxkIG5lZWQgdG8gbG9vayB1cFxuLy8gICAgMy4gU29tZSBFWERBVEUgZW50cmllcyBpbiB0aGUgd2lsZCBzZWVtIHRvIGhhdmUgdGltZXMgZGlmZmVyZW50IGZyb20gdGhlIHJlY3VycmVuY2UgcnVsZSwgYnV0IGFyZSBzdGlsbCBleGNsdWRlZCBieSBjYWxlbmRhciBwcm9ncmFtcy4gIE5vdCBzdXJlIGhvdyBvciB3aHkuXG4vLyAgICAgICBUaGVzZSB3b3VsZCBmYWlsIGFueSBzb3J0IG9mIHNhbmUgdGltZSBsb29rdXAsIGJlY2F1c2UgdGhlIHRpbWUgbGl0ZXJhbGx5IGRvZXNuJ3QgbWF0Y2ggdGhlIGV2ZW50LiAgU28gd2UnbGwgaWdub3JlIHRpbWUgYW5kIGp1c3QgdXNlIGRhdGUuXG4vLyAgICAgICBleDogRFRTVEFSVDoyMDE3MDgxNFQxNDAwMDBaXG4vLyAgICAgICAgICAgICBSUlVMRTpGUkVRPVdFRUtMWTtXS1NUPVNVO0lOVEVSVkFMPTI7QllEQVk9TU8sVFVcbi8vICAgICAgICAgICAgIEVYREFURToyMDE3MTIxOVQwNjAwMDBcbi8vICAgICAgIEV2ZW4gdGhvdWdoIFwiVDA2MDAwMFwiIGRvZXNuJ3QgbWF0Y2ggb3Igb3ZlcmxhcCBcIlQxNDAwMDAwWlwiLCBpdCdzIHN0aWxsIHN1cHBvc2VkIHRvIGJlIGV4Y2x1ZGVkPyAgT2RkLiA6KFxuLy8gVE9ETzogU2VlIGlmIHRoaXMgY2F1c2VzIGFueSBwcm9ibGVtcyB3aXRoIGV2ZW50cyB0aGF0IHJlY3VyIG11bHRpcGxlIHRpbWVzIGEgZGF5LlxuY29uc3QgZXhkYXRlUGFyYW1ldGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgcGFyYW1ldGVycywgY3Vycikge1xuICAgIGNvbnN0IHNlcGFyYXRvclBhdHRlcm4gPSAvXFxzKixcXHMqL2c7XG4gICAgY3VycltuYW1lXSA9IGN1cnJbbmFtZV0gfHwgW107XG4gICAgY29uc3QgZGF0ZXMgPSB2YWx1ZSA/IHZhbHVlLnNwbGl0KHNlcGFyYXRvclBhdHRlcm4pIDogW107XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBkYXRlcykge1xuICAgICAgY29uc3QgZXhkYXRlID0gW107XG4gICAgICBkYXRlUGFyYW1ldGVyKG5hbWUpKGVudHJ5LCBwYXJhbWV0ZXJzLCBleGRhdGUpO1xuXG4gICAgICBpZiAoZXhkYXRlW25hbWVdKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXhkYXRlW25hbWVdLnRvSVNPU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY3VycltuYW1lXVtleGRhdGVbbmFtZV0udG9JU09TdHJpbmcoKS5zbGljZSgwLCAxMCldID0gZXhkYXRlW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vIHRvSVNPU3RyaW5nIGZ1bmN0aW9uIGluIGV4ZGF0ZVtuYW1lXScsIGV4ZGF0ZVtuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY3VycjtcbiAgfTtcbn07XG5cbi8vIFJFQ1VSUkVOQ0UtSUQgaXMgdGhlIElEIG9mIGEgc3BlY2lmaWMgcmVjdXJyZW5jZSB3aXRoaW4gYSByZWN1cnJlbmNlIHJ1bGUuXG4vLyBUT0RPOiAgSXQncyBhbHNvIHBvc3NpYmxlIGZvciBpdCB0byBoYXZlIGEgcmFuZ2UsIGxpa2UgXCJUSElTQU5EUFJJT1JcIiwgXCJUSElTQU5ERlVUVVJFXCIuICBUaGlzIGlzbid0IGN1cnJlbnRseSBoYW5kbGVkLlxuY29uc3QgcmVjdXJyZW5jZVBhcmFtZXRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBkYXRlUGFyYW1ldGVyKG5hbWUpO1xufTtcblxuY29uc3QgYWRkRkJUeXBlID0gZnVuY3Rpb24gKGZiLCBwYXJhbWV0ZXJzKSB7XG4gIGNvbnN0IHAgPSBwYXJzZVBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG5cbiAgaWYgKHBhcmFtZXRlcnMgJiYgcCkge1xuICAgIGZiLnR5cGUgPSBwLkZCVFlQRSB8fCAnQlVTWSc7XG4gIH1cblxuICByZXR1cm4gZmI7XG59O1xuXG5jb25zdCBmcmVlYnVzeVBhcmFtZXRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIHBhcmFtZXRlcnMsIGN1cnIpIHtcbiAgICBjb25zdCBmYiA9IGFkZEZCVHlwZSh7fSwgcGFyYW1ldGVycyk7XG4gICAgY3VycltuYW1lXSA9IGN1cnJbbmFtZV0gfHwgW107XG4gICAgY3VycltuYW1lXS5wdXNoKGZiKTtcblxuICAgIHN0b3JlUGFyYW1ldGVyKHZhbHVlLCBwYXJhbWV0ZXJzLCBmYik7XG5cbiAgICBjb25zdCBwYXJ0cyA9IHZhbHVlLnNwbGl0KCcvJyk7XG5cbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgbmFtZV0gb2YgWydzdGFydCcsICdlbmQnXS5lbnRyaWVzKCkpIHtcbiAgICAgIGRhdGVQYXJhbWV0ZXIobmFtZSkocGFydHNbaW5kZXhdLCBwYXJhbWV0ZXJzLCBmYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnI7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb2JqZWN0SGFuZGxlcnM6IHtcbiAgICBCRUdJTihjb21wb25lbnQsIHBhcmFtZXRlcnMsIGN1cnIsIHN0YWNrKSB7XG4gICAgICBzdGFjay5wdXNoKGN1cnIpO1xuXG4gICAgICByZXR1cm4ge3R5cGU6IGNvbXBvbmVudCwgcGFyYW1zOiBwYXJhbWV0ZXJzfTtcbiAgICB9LFxuICAgIEVORCh2YWx1ZSwgcGFyYW1ldGVycywgY3Vyciwgc3RhY2spIHtcbiAgICAgIC8vIE9yaWdpbmFsIGVuZCBmdW5jdGlvblxuICAgICAgY29uc3Qgb3JpZ2luYWxFbmQgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBwYXJhbWV0ZXJzXywgY3Vyciwgc3RhY2spIHtcbiAgICAgICAgLy8gUHJldmVudHMgdGhlIG5lZWQgdG8gc2VhcmNoIHRoZSByb290IG9mIHRoZSB0cmVlIGZvciB0aGUgVkNBTEVOREFSIG9iamVjdFxuICAgICAgICBpZiAoY29tcG9uZW50ID09PSAnVkNBTEVOREFSJykge1xuICAgICAgICAgIC8vIFNjYW4gYWxsIGhpZ2ggbGV2ZWwgb2JqZWN0IGluIGN1cnIgYW5kIGRyb3AgYWxsIHN0cmluZ3NcbiAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgIGxldCBvYmplY3Q7XG4gICAgICAgICAgY29uc3QgaGlnaExldmVsID0ge307XG5cbiAgICAgICAgICBmb3IgKGtleSBpbiBjdXJyKSB7XG4gICAgICAgICAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoY3Vyciwga2V5KSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqZWN0ID0gY3VycltrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGhpZ2hMZXZlbFtrZXldID0gb2JqZWN0O1xuICAgICAgICAgICAgICBkZWxldGUgY3VycltrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChoaWdoTGV2ZWwudHlwZSkge1xuICAgICAgICAgICAgY3VycltoaWdoTGV2ZWwudHlwZS50b0xvd2VyQ2FzZSgpXSA9IGhpZ2hMZXZlbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY3VycjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhciA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmICghY3Vyci5lbmQpIHsgLy8gUkZDNTU0NSwgMy42LjFcbiAgICAgICAgICBpZiAoY3Vyci5kYXRldHlwZSA9PT0gJ2RhdGUtdGltZScpIHtcbiAgICAgICAgICAgIGN1cnIuZW5kID0gbmV3IERhdGUoY3Vyci5zdGFydC5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGR1cmF0aW9uIGlzIG5vdCBzZXRcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnIuZHVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gU2V0IHRoZSBlbmQgdG8gdGhlIHN0YXJ0IHBsdXMgb25lIGRheSBSRkM1NTQ1LCAzLjYuMVxuICAgICAgICAgICAgY3Vyci5lbmQgPSBtb21lbnQudXRjKGN1cnIuc3RhcnQpLmFkZCgxLCAnZGF5cycpLnRvRGF0ZSgpOyAvLyBOZXcgRGF0ZShtb21lbnQoY3Vyci5zdGFydCkuYWRkKDEsICdkYXlzJykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvblVuaXRzID1cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIFk6ICd5ZWFycycsXG4gICAgICAgICAgICAgICAgLy8gTTogJ21vbnRocycsXG4gICAgICAgICAgICAgICAgVzogJ3dlZWtzJyxcbiAgICAgICAgICAgICAgICBEOiAnZGF5cycsXG4gICAgICAgICAgICAgICAgSDogJ2hvdXJzJyxcbiAgICAgICAgICAgICAgICBNOiAnbWludXRlcycsXG4gICAgICAgICAgICAgICAgUzogJ3NlY29uZHMnXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGxpc3Qgb2YgZHVyYXRpb24gZWxlbWVudHNcbiAgICAgICAgICAgIGNvbnN0IHIgPSBjdXJyLmR1cmF0aW9uLm1hdGNoKC8tP1xcZCtbWU1XREhTXS9nKTtcbiAgICAgICAgICAgIGxldCBuZXdlbmQgPSBtb21lbnQudXRjKGN1cnIuc3RhcnQpO1xuICAgICAgICAgICAgLy8gSXMgdGhlIDFzdCBjaGFyYWN0ZXIgYSBuZWdhdGl2ZSBzaWduP1xuICAgICAgICAgICAgY29uc3QgaW5kaWNhdG9yID0gY3Vyci5kdXJhdGlvbi5zdGFydHNXaXRoKCctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIGVhY2ggZWxlbWVudFxuICAgICAgICAgICAgZm9yIChjb25zdCBkIG9mIHIpIHtcbiAgICAgICAgICAgICAgbmV3ZW5kID0gbmV3ZW5kLmFkZChOdW1iZXIucGFyc2VJbnQoZCwgMTApICogaW5kaWNhdG9yLCBkdXJhdGlvblVuaXRzW2Quc2xpY2UoLTEpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnIuZW5kID0gbmV3ZW5kLnRvRGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyLnVpZCkge1xuICAgICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2UgcnVuIGludG8gdGhpcyBVSUQsIGp1c3Qgc2F2ZSBpdC5cbiAgICAgICAgICBpZiAocGFyW2N1cnIudWlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJbY3Vyci51aWRdID0gY3VycjtcblxuICAgICAgICAgICAgaWYgKHBhci5tZXRob2QpIHsgLy8gUkZDNTU0NSwgMy4yXG4gICAgICAgICAgICAgIHBhcltjdXJyLnVpZF0ubWV0aG9kID0gcGFyLm1ldGhvZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnIucmVjdXJyZW5jZWlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgbXVsdGlwbGUgaWNhbCBlbnRyaWVzIHdpdGggdGhlIHNhbWUgVUlELCBpdCdzIGVpdGhlciBnb2luZyB0byBiZSBhXG4gICAgICAgICAgICAvLyBtb2RpZmljYXRpb24gdG8gYSByZWN1cnJlbmNlIChSRUNVUlJFTkNFLUlEKSwgYW5kL29yIGEgc2lnbmlmaWNhbnQgbW9kaWZpY2F0aW9uXG4gICAgICAgICAgICAvLyB0byB0aGUgZW50cnkgKFNFUVVFTkNFKS5cblxuICAgICAgICAgICAgLy8gVE9ETzogTG9vayBpbnRvIHByb3BlciBzZXF1ZW5jZSBsb2dpYy5cblxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSB0aGUgc2FtZSBVSUQgYXMgYW4gZXhpc3RpbmcgcmVjb3JkLCBhbmQgaXQgKmlzbid0KiBhIHNwZWNpZmljIHJlY3VycmVuY2UgSUQsXG4gICAgICAgICAgICAvLyBub3QgcXVpdGUgc3VyZSB3aGF0IHRoZSBjb3JyZWN0IGJlaGF2aW91ciBzaG91bGQgYmUuICBGb3Igbm93LCBqdXN0IHRha2UgdGhlIG5ldyBpbmZvcm1hdGlvblxuICAgICAgICAgICAgLy8gYW5kIG1lcmdlIGl0IHdpdGggdGhlIG9sZCByZWNvcmQgYnkgb3ZlcndyaXRpbmcgb25seSB0aGUgZmllbGRzIHRoYXQgYXBwZWFyIGluIHRoZSBuZXcgcmVjb3JkLlxuICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgIGZvciAoa2V5IGluIGN1cnIpIHtcbiAgICAgICAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhcltjdXJyLnVpZF1ba2V5XSA9IGN1cnJba2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHdlIGhhdmUgcmVjdXJyZW5jZS1pZCBlbnRyaWVzLCBsaXN0IHRoZW0gYXMgYW4gYXJyYXkgb2YgcmVjdXJyZW5jZXMga2V5ZWQgb2ZmIG9mIHJlY3VycmVuY2UtaWQuXG4gICAgICAgICAgLy8gVG8gdXNlIC0gYXMgeW91J3JlIHJ1bm5pbmcgdGhyb3VnaCB0aGUgZGF0ZXMgb2YgYW4gcnJ1bGUsIHlvdSBjYW4gdHJ5IGxvb2tpbmcgaXQgdXAgaW4gdGhlIHJlY3VycmVuY2VzXG4gICAgICAgICAgLy8gYXJyYXkuICBJZiBpdCBleGlzdHMsIHRoZW4gdXNlIHRoZSBkYXRhIGZyb20gdGhlIGNhbGVuZGFyIG9iamVjdCBpbiB0aGUgcmVjdXJyZW5jZSBpbnN0ZWFkIG9mIHRoZSBwYXJlbnRcbiAgICAgICAgICAvLyBmb3IgdGhhdCBkYXkuXG5cbiAgICAgICAgICAvLyBOT1RFOiAgU29tZXRpbWVzIHRoZSBSRUNVUlJFTkNFLUlEIHJlY29yZCB3aWxsIHNob3cgdXAgKmJlZm9yZSogdGhlIHJlY29yZCB3aXRoIHRoZSBSUlVMRSBlbnRyeS4gIEluIHRoYXRcbiAgICAgICAgICAvLyBjYXNlLCB3aGF0IGhhcHBlbnMgaXMgdGhhdCB0aGUgUkVDVVJSRU5DRS1JRCByZWNvcmQgZW5kcyB1cCBiZWNvbWluZyBib3RoIHRoZSBwYXJlbnQgcmVjb3JkIGFuZCBhbiBlbnRyeVxuICAgICAgICAgIC8vIGluIHRoZSByZWN1cnJlbmNlcyBhcnJheSwgYW5kIHRoZW4gd2hlbiB3ZSBwcm9jZXNzIHRoZSBSUlVMRSBlbnRyeSBsYXRlciBpdCBvdmVyd3JpdGVzIHRoZSBhcHByb3ByaWF0ZVxuICAgICAgICAgIC8vIGZpZWxkcyBpbiB0aGUgcGFyZW50IHJlY29yZC5cblxuICAgICAgICAgIGlmICh0eXBlb2YgY3Vyci5yZWN1cnJlbmNlaWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiAgSXMgdGhlcmUgZXZlciBhIGNhc2Ugd2hlcmUgd2UgaGF2ZSB0byB3b3JyeSBhYm91dCBvdmVyd3JpdGluZyBhbiBleGlzdGluZyBlbnRyeSBoZXJlP1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBjdXJyZW50IG9iamVjdCB0byBzYXZlIGluIG91ciByZWN1cnJlbmNlcyBhcnJheS4gIChXZSAqY291bGQqIGp1c3QgZG8gcGFyID0gY3VycixcbiAgICAgICAgICAgIC8vIGV4Y2VwdCBmb3IgdGhlIGNhc2UgdGhhdCB3ZSBnZXQgdGhlIFJFQ1VSUkVOQ0UtSUQgcmVjb3JkIGJlZm9yZSB0aGUgUlJVTEUgcmVjb3JkLiAgSW4gdGhhdCBjYXNlLCB3ZVxuICAgICAgICAgICAgLy8gd291bGQgZW5kIHVwIHdpdGggYSBzaGFyZWQgcmVmZXJlbmNlIHRoYXQgd291bGQgY2F1c2UgdXMgdG8gb3ZlcndyaXRlICpib3RoKiByZWNvcmRzIGF0IHRoZSBwb2ludFxuICAgICAgICAgICAgLy8gdGhhdCB3ZSB0cnkgYW5kIGZpeCB1cCB0aGUgcGFyZW50IHJlY29yZC4pXG4gICAgICAgICAgICBjb25zdCByZWN1cnJlbmNlT2JqZWN0ID0ge307XG4gICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgZm9yIChrZXkgaW4gY3Vycikge1xuICAgICAgICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVjdXJyZW5jZU9iamVjdFtrZXldID0gY3VycltrZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVjdXJyZW5jZU9iamVjdC5yZWN1cnJlbmNlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHJlY3VycmVuY2VPYmplY3QucmVjdXJyZW5jZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW4gYXJyYXkgdG8gc3RvcmUgcmVjdXJyZW5jZXMgaW4geWV0LCBjcmVhdGUgaXQuXG4gICAgICAgICAgICBpZiAocGFyW2N1cnIudWlkXS5yZWN1cnJlbmNlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHBhcltjdXJyLnVpZF0ucmVjdXJyZW5jZXMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2F2ZSBvZmYgb3VyIGNsb25lZCByZWN1cnJlbmNlIG9iamVjdCBpbnRvIHRoZSBhcnJheSwga2V5ZWQgYnkgZGF0ZSBidXQgbm90IHRpbWUuXG4gICAgICAgICAgICAvLyBXZSBrZXkgYnkgZGF0ZSBvbmx5IHRvIGF2b2lkIHRpbWV6b25lIGFuZCBcImZsb2F0aW5nIHRpbWVcIiBwcm9ibGVtcyAod2hlcmUgdGhlIHRpbWUgaXNuJ3QgYXNzb2NpYXRlZCB3aXRoIGEgdGltZXpvbmUpLlxuICAgICAgICAgICAgLy8gVE9ETzogU2VlIGlmIHRoaXMgY2F1c2VzIGEgcHJvYmxlbSB3aXRoIGV2ZW50cyB0aGF0IGhhdmUgbXVsdGlwbGUgcmVjdXJyZW5jZXMgcGVyIGRheS5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3Vyci5yZWN1cnJlbmNlaWQudG9JU09TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcGFyW2N1cnIudWlkXS5yZWN1cnJlbmNlc1tjdXJyLnJlY3VycmVuY2VpZC50b0lTT1N0cmluZygpLnNsaWNlKDAsIDEwKV0gPSByZWN1cnJlbmNlT2JqZWN0O1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gUmVtb3ZlZCBpc3N1ZSA1NlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdObyB0b0lTT1N0cmluZyBmdW5jdGlvbiBpbiBjdXJyLnJlY3VycmVuY2VpZCcsIGN1cnIucmVjdXJyZW5jZWlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPbmUgbW9yZSBzcGVjaWZpYyBmaXggLSBpbiB0aGUgY2FzZSB0aGF0IGFuIFJSVUxFIGVudHJ5IHNob3dzIHVwIGFmdGVyIGEgUkVDVVJSRU5DRS1JRCBlbnRyeSxcbiAgICAgICAgICAvLyBsZXQncyBtYWtlIHN1cmUgdG8gY2xlYXIgdGhlIHJlY3VycmVuY2VpZCBvZmYgdGhlIHBhcmVudCBmaWVsZC5cbiAgICAgICAgICBpZiAodHlwZW9mIHBhcltjdXJyLnVpZF0ucnJ1bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwYXJbY3Vyci51aWRdLnJlY3VycmVuY2VpZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwYXJbY3Vyci51aWRdLnJlY3VycmVuY2VpZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgaWQgPSB1dWlkKCk7XG4gICAgICAgICAgcGFyW2lkXSA9IGN1cnI7XG5cbiAgICAgICAgICBpZiAocGFyLm1ldGhvZCkgeyAvLyBSRkM1NTQ1LCAzLjJcbiAgICAgICAgICAgIHBhcltpZF0ubWV0aG9kID0gcGFyLm1ldGhvZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyO1xuICAgICAgfTtcblxuICAgICAgLy8gUmVjdXJyZW5jZSBydWxlcyBhcmUgb25seSB2YWxpZCBmb3IgVkVWRU5ULCBWVE9ETywgYW5kIFZKT1VSTkFMLlxuICAgICAgLy8gTW9yZSBzcGVjaWZpY2FsbHksIHdlIG5lZWQgdG8gZmlsdGVyIHRoZSBWQ0FMRU5EQVIgdHlwZSBiZWNhdXNlIHdlIG1pZ2h0IGVuZCB1cCB3aXRoIGEgZGVmaW5lZCBycnVsZVxuICAgICAgLy8gZHVlIHRvIHRoZSBzdWJ0eXBlcy5cblxuICAgICAgaWYgKCh2YWx1ZSA9PT0gJ1ZFVkVOVCcgfHwgdmFsdWUgPT09ICdWVE9ETycgfHwgdmFsdWUgPT09ICdWSk9VUk5BTCcpICYmIGN1cnIucnJ1bGUpIHtcbiAgICAgICAgbGV0IHJ1bGUgPSBjdXJyLnJydWxlLnJlcGxhY2UoJ1JSVUxFOicsICcnKTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBycnVsZSBzdGFydHMgd2l0aCBGUkVRPVxuICAgICAgICBydWxlID0gcnVsZS5zbGljZShydWxlLmxhc3RJbmRleE9mKCdGUkVRPScpKTtcbiAgICAgICAgLy8gSWYgbm8gcnVsZSBzdGFydCBkYXRlXG4gICAgICAgIGlmIChydWxlLmluY2x1ZGVzKCdEVFNUQVJUJykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gR2V0IGRhdGUvdGltZSBpbnRvIGEgc3BlY2lmaWMgZm9ybWF0IGZvciBjb21hcGFyZVxuICAgICAgICAgIGxldCB4ID0gbW9tZW50KGN1cnIuc3RhcnQpLmZvcm1hdCgnTU1NTS9Eby9ZWVlZLCBoOm1tOnNzIGEnKTtcbiAgICAgICAgICAvLyBJZiB0aGUgbG9jYWwgdGltZSB2YWx1ZSBpcyBtaWRuaWdodFxuICAgICAgICAgIC8vIFRoaXMgYSB3aG9sZSBkYXkgZXZlbnRcbiAgICAgICAgICBpZiAoeC5zbGljZSgtMTEpID09PSAnMTI6MDA6MDAgYW0nKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHRpbWV6b25lIG9mZnNldFxuICAgICAgICAgICAgLy8gVGhlIGludGVybmFsIGRhdGUgaXMgc3RvcmVkIGluIFVUQyBmb3JtYXRcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGN1cnIuc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgICAgIC8vIE9ubHkgZWFzdCBvZiBnbXQgaXMgYSBwcm9ibGVtXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG5ldyBzdGFydGRhdGUgd2l0aCB0aGUgb2Zmc2V0IGFwcGxpZWQsIGJ5cGFzcyBSUlVMRS9MdXhvbiBjb25mdXNpb25cbiAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgaW50ZXJuYWxseSBzdG9yZWQgREFURSB0aGUgYWN0dWFsIGRhdGUgKG5vdCBVVEMgb2Zmc2V0ZWQpXG4gICAgICAgICAgICAgIC8vIEx1eG9uIGV4cGVjdHMgbG9jYWwgdGltZSwgbm90IHV0Yywgc28gZ2V0cyBzdGFydCBkYXRlIHdyb25nIGlmIG5vdCBhZGp1c3RlZFxuICAgICAgICAgICAgICBjdXJyLnN0YXJ0ID0gbmV3IERhdGUoY3Vyci5zdGFydC5nZXRUaW1lKCkgKyAoTWF0aC5hYnMob2Zmc2V0KSAqIDYwMDAwKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBHZXQgcmlkIG9mIGFueSB0aW1lIChzaG91bGRuJ3QgYmUgYW55LCBidXQgYmUgc3VyZSlcbiAgICAgICAgICAgICAgeCA9IG1vbWVudChjdXJyLnN0YXJ0KS5mb3JtYXQoJ01NTU0vRG8vWVlZWScpO1xuICAgICAgICAgICAgICBjb25zdCBjb21wcyA9IC9eKFxcZHsyfSlcXC8oXFxkezJ9KVxcLyhcXGR7NH0pLy5leGVjKHgpO1xuICAgICAgICAgICAgICBpZiAoY29tcHMpIHtcbiAgICAgICAgICAgICAgICBjdXJyLnN0YXJ0ID0gbmV3IERhdGUoY29tcHNbM10sIGNvbXBzWzFdIC0gMSwgY29tcHNbMl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIGRhdGUgaGFzIGFuIHRvSVNPU3RyaW5nIGZ1bmN0aW9uXG4gICAgICAgICAgaWYgKGN1cnIuc3RhcnQgJiYgdHlwZW9mIGN1cnIuc3RhcnQudG9JU09TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBvcmlnaW5hbCBkYXRlIGhhcyBhIFRaSUQsIGFkZCBpdFxuICAgICAgICAgICAgICBpZiAoY3Vyci5zdGFydC50eikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR6ID0gZ2V0VGltZVpvbmUoY3Vyci5zdGFydC50eik7XG4gICAgICAgICAgICAgICAgcnVsZSArPSBgO0RUU1RBUlQ7VFpJRD0ke3R6fToke2N1cnIuc3RhcnQudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9bLTpdL2csICcnKX1gO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJ1bGUgKz0gYDtEVFNUQVJUPSR7Y3Vyci5zdGFydC50b0lTT1N0cmluZygpLnJlcGxhY2UoL1stOl0vZywgJycpfWA7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBydWxlID0gcnVsZS5yZXBsYWNlKC9cXC5cXGR7M30vLCAnJyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgeyAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBpc3N1ZSAjNTZcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFUlJPUiB3aGVuIHRyeWluZyB0byBjb252ZXJ0IHRvIElTT1N0cmluZycsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB0b0lTT1N0cmluZyBmdW5jdGlvbiBpbiBjdXJyLnN0YXJ0JywgY3Vyci5zdGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRvIGNhdGNoIGVycm9yIGZyb20gcnJ1bGUuZnJvbVN0cmluZygpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY3Vyci5ycnVsZSA9IHJydWxlLmZyb21TdHJpbmcocnVsZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9yaWdpbmFsRW5kLmNhbGwodGhpcywgdmFsdWUsIHBhcmFtZXRlcnMsIGN1cnIsIHN0YWNrKTtcbiAgICB9LFxuICAgIFNVTU1BUlk6IHN0b3JlUGFyYW1ldGVyKCdzdW1tYXJ5JyksXG4gICAgREVTQ1JJUFRJT046IHN0b3JlUGFyYW1ldGVyKCdkZXNjcmlwdGlvbicpLFxuICAgIFVSTDogc3RvcmVQYXJhbWV0ZXIoJ3VybCcpLFxuICAgIFVJRDogc3RvcmVQYXJhbWV0ZXIoJ3VpZCcpLFxuICAgIExPQ0FUSU9OOiBzdG9yZVBhcmFtZXRlcignbG9jYXRpb24nKSxcbiAgICBEVFNUQVJUKHZhbHVlLCBwYXJhbWV0ZXJzLCBjdXJyLCBzdGFjaykge1xuICAgICAgY3VyciA9IGRhdGVQYXJhbWV0ZXIoJ3N0YXJ0JykodmFsdWUsIHBhcmFtZXRlcnMsIGN1cnIsIHN0YWNrKTtcbiAgICAgIHJldHVybiB0eXBlUGFyYW1ldGVyKCdkYXRldHlwZScpKHZhbHVlLCBwYXJhbWV0ZXJzLCBjdXJyKTtcbiAgICB9LFxuICAgIERURU5EOiBkYXRlUGFyYW1ldGVyKCdlbmQnKSxcbiAgICBFWERBVEU6IGV4ZGF0ZVBhcmFtZXRlcignZXhkYXRlJyksXG4gICAgJyBDTEFTUyc6IHN0b3JlUGFyYW1ldGVyKCdjbGFzcycpLCAvLyBTaG91bGQgdGhlcmUgYmUgYSBzcGFjZSBpbiB0aGlzIHByb3BlcnR5P1xuICAgIFRSQU5TUDogc3RvcmVQYXJhbWV0ZXIoJ3RyYW5zcGFyZW5jeScpLFxuICAgIEdFTzogZ2VvUGFyYW1ldGVyKCdnZW8nKSxcbiAgICAnUEVSQ0VOVC1DT01QTEVURSc6IHN0b3JlUGFyYW1ldGVyKCdjb21wbGV0aW9uJyksXG4gICAgQ09NUExFVEVEOiBkYXRlUGFyYW1ldGVyKCdjb21wbGV0ZWQnKSxcbiAgICBDQVRFR09SSUVTOiBjYXRlZ29yaWVzUGFyYW1ldGVyKCdjYXRlZ29yaWVzJyksXG4gICAgRlJFRUJVU1k6IGZyZWVidXN5UGFyYW1ldGVyKCdmcmVlYnVzeScpLFxuICAgIERUU1RBTVA6IGRhdGVQYXJhbWV0ZXIoJ2R0c3RhbXAnKSxcbiAgICBDUkVBVEVEOiBkYXRlUGFyYW1ldGVyKCdjcmVhdGVkJyksXG4gICAgJ0xBU1QtTU9ESUZJRUQnOiBkYXRlUGFyYW1ldGVyKCdsYXN0bW9kaWZpZWQnKSxcbiAgICAnUkVDVVJSRU5DRS1JRCc6IHJlY3VycmVuY2VQYXJhbWV0ZXIoJ3JlY3VycmVuY2VpZCcpLFxuICAgIFJSVUxFKHZhbHVlLCBwYXJhbWV0ZXJzLCBjdXJyLCBzdGFjaywgbGluZSkge1xuICAgICAgY3Vyci5ycnVsZSA9IGxpbmU7XG4gICAgICByZXR1cm4gY3VycjtcbiAgICB9XG4gIH0sXG5cbiAgaGFuZGxlT2JqZWN0KG5hbWUsIHZhbHVlLCBwYXJhbWV0ZXJzLCBjdHgsIHN0YWNrLCBsaW5lKSB7XG4gICAgaWYgKHRoaXMub2JqZWN0SGFuZGxlcnNbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0aGlzLm9iamVjdEhhbmRsZXJzW25hbWVdKHZhbHVlLCBwYXJhbWV0ZXJzLCBjdHgsIHN0YWNrLCBsaW5lKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGluZyBjdXN0b20gcHJvcGVydGllc1xuICAgIGlmICgvWC1bXFx3LV0rLy50ZXN0KG5hbWUpICYmIHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFRyaW1taW5nIHRoZSBsZWFkaW5nIGFuZCBwZXJmb3JtIHN0b3JlUGFyYW1cbiAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDIpO1xuICAgICAgcmV0dXJuIHN0b3JlUGFyYW1ldGVyKG5hbWUpKHZhbHVlLCBwYXJhbWV0ZXJzLCBjdHgsIHN0YWNrLCBsaW5lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RvcmVQYXJhbWV0ZXIobmFtZS50b0xvd2VyQ2FzZSgpKSh2YWx1ZSwgcGFyYW1ldGVycywgY3R4KTtcbiAgfSxcblxuICBwYXJzZUxpbmVzKGxpbmVzLCBsaW1pdCwgY3R4LCBzdGFjaywgbGFzdEluZGV4LCBjYikge1xuICAgIGlmICghY2IgJiYgdHlwZW9mIGN0eCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBjdHg7XG4gICAgICBjdHggPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY3R4ID0gY3R4IHx8IHt9O1xuICAgIHN0YWNrID0gc3RhY2sgfHwgW107XG5cbiAgICBsZXQgbGltaXRDb3VudGVyID0gMDtcblxuICAgIGxldCBpID0gbGFzdEluZGV4IHx8IDA7XG4gICAgZm9yIChsZXQgaWkgPSBsaW5lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBsZXQgbCA9IGxpbmVzW2ldO1xuICAgICAgLy8gVW5mb2xkIDogUkZDIzMuMVxuICAgICAgd2hpbGUgKGxpbmVzW2kgKyAxXSAmJiAvWyBcXHRdLy50ZXN0KGxpbmVzW2kgKyAxXVswXSkpIHtcbiAgICAgICAgbCArPSBsaW5lc1tpICsgMV0uc2xpY2UoMSk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGFueSBkb3VibGUgcXVvdGVzIGluIGFueSB0emlkIHN0YXRlbWVudC8vIGV4Y2VwdCBhcm91bmQgKHV0YytoaDptbVxuICAgICAgaWYgKGwuaW5kZXhPZignVFpJRD0nKSAmJiAhbC5pbmNsdWRlcygnXCIoJykpIHtcbiAgICAgICAgbCA9IGwucmVwbGFjZSgvXCIvZywgJycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBleHAgPSAvXihbXFx3XFxkLV0rKSgoPzo7W1xcd1xcZC1dKz0oPzooPzpcIlteXCJdKlwiKXxbXlwiOjtdKykpKik6KC4qKSQvO1xuICAgICAgbGV0IGt2ID0gbC5tYXRjaChleHApO1xuXG4gICAgICBpZiAoa3YgPT09IG51bGwpIHtcbiAgICAgICAgLy8gSW52YWxpZCBsaW5lIC0gbXVzdCBoYXZlIGsmdlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAga3YgPSBrdi5zbGljZSgxKTtcblxuICAgICAgY29uc3QgdmFsdWUgPSBrdltrdi5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IG5hbWUgPSBrdlswXTtcbiAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBrdlsxXSA/IGt2WzFdLnNwbGl0KCc7Jykuc2xpY2UoMSkgOiBbXTtcblxuICAgICAgY3R4ID0gdGhpcy5oYW5kbGVPYmplY3QobmFtZSwgdmFsdWUsIHBhcmFtZXRlcnMsIGN0eCwgc3RhY2ssIGwpIHx8IHt9O1xuICAgICAgaWYgKCsrbGltaXRDb3VudGVyID4gbGltaXQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGkgPj0gbGluZXMubGVuZ3RoKSB7XG4gICAgICAvLyBUeXBlIGFuZCBwYXJhbXMgYXJlIGFkZGVkIHRvIHRoZSBsaXN0IG9mIGl0ZW1zLCBnZXQgcmlkIG9mIHRoZW0uXG4gICAgICBkZWxldGUgY3R4LnR5cGU7XG4gICAgICBkZWxldGUgY3R4LnBhcmFtcztcbiAgICB9XG5cbiAgICBpZiAoY2IpIHtcbiAgICAgIGlmIChpIDwgbGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5wYXJzZUxpbmVzKGxpbmVzLCBsaW1pdCwgY3R4LCBzdGFjaywgaSArIDEsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgIGNiKG51bGwsIGN0eCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4O1xuICAgIH1cbiAgfSxcblxuICBwYXJzZUlDUyhzdHJpbmcsIGNiKSB7XG4gICAgY29uc3QgbGluZXMgPSBzdHJpbmcuc3BsaXQoL1xccj9cXG4vKTtcbiAgICBsZXQgY3R4O1xuXG4gICAgaWYgKGNiKSB7XG4gICAgICAvLyBBc3luY2hyb25vdXMgZXhlY3V0aW9uXG4gICAgICB0aGlzLnBhcnNlTGluZXMobGluZXMsIDIwMDAsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3luY2hyb25vdXMgZXhlY3V0aW9uXG4gICAgICBjdHggPSB0aGlzLnBhcnNlTGluZXMobGluZXMsIGxpbmVzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gY3R4O1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-ical/ical.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-ical/node-ical.js":
/*!*********************************************!*\
  !*** ./node_modules/node-ical/node-ical.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\");\nconst axios = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/dist/node/axios.cjs\");\nconst ical = __webpack_require__(/*! ./ical.js */ \"(ssr)/./node_modules/node-ical/ical.js\");\n\n/**\n * ICal event object.\n *\n * These two fields are always present:\n *  - type\n *  - params\n *\n * The rest of the fields may or may not be present depending on the input.\n * Do not assume any of these fields are valid and check them before using.\n * Most types are simply there as a general guide for IDEs and users.\n *\n * @typedef iCalEvent\n * @type {object}\n *\n * @property {string} type           - Type of event.\n * @property {Array} params          - Extra event parameters.\n *\n * @property {?object} start         - When this event starts.\n * @property {?object} end           - When this event ends.\n *\n * @property {?string} summary       - Event summary string.\n * @property {?string} description   - Event description.\n *\n * @property {?object} dtstamp       - DTSTAMP field of this event.\n *\n * @property {?object} created       - When this event was created.\n * @property {?object} lastmodified  - When this event was last modified.\n *\n * @property {?string} uid           - Unique event identifier.\n *\n * @property {?string} status        - Event status.\n *\n * @property {?string} sequence      - Event sequence.\n *\n * @property {?string} url           - URL of this event.\n *\n * @property {?string} location      - Where this event occurs.\n * @property {?{\n *     lat: number, lon: number\n * }} geo                            - Lat/lon location of this event.\n *\n * @property {?Array.<string>}       - Array of event catagories.\n */\n/**\n * Object containing iCal events.\n * @typedef {Object.<string, iCalEvent>} iCalData\n */\n/**\n * Callback for iCal parsing functions with error and iCal data as a JavaScript object.\n * @callback icsCallback\n * @param {Error} err\n * @param {iCalData} ics\n */\n/**\n * A Promise that is undefined if a compatible callback is passed.\n * @typedef {(Promise.<iCalData>|undefined)} optionalPromise\n */\n\n// utility to allow callbacks to be used for promises\nfunction promiseCallback(fn, cb) {\n  const promise = new Promise(fn);\n  if (!cb) {\n    return promise;\n  }\n\n  promise\n    .then(returnValue => {\n      cb(null, returnValue);\n    })\n    .catch(error => {\n      cb(error, null);\n    });\n}\n\n// Sync functions\nconst sync = {};\n// Async functions\nconst async = {};\n// Auto-detect functions for backwards compatibility.\nconst autodetect = {};\n\n/**\n * Download an iCal file from the web and parse it.\n *\n * @param {string} url                - URL of file to request.\n * @param {Object|icsCallback} [opts] - Options to pass to axios.get() from npm:axios.\n *                                      Alternatively you can pass the callback function directly.\n *                                      If no callback is provided a promise will be returned.\n * @param {icsCallback} [cb]          - Callback function.\n *                                      If no callback is provided a promise will be returned.\n *\n * @returns {optionalPromise} Promise is returned if no callback is passed.\n */\nasync.fromURL = function (url, options, cb) {\n  return promiseCallback((resolve, reject) => {\n    axios.get(url, options)\n      .then(response => {\n        // If (response.status !== 200) {\n        // all ok status codes should be accepted (any 2XX code)\n        if (Math.floor(response.status / 100) !== 2) {\n          reject(new Error(`${response.status} ${response.statusText}`));\n          return;\n        }\n\n        return response.data;\n      })\n      .then(data => {\n        ical.parseICS(data, (error, ics) => {\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          resolve(ics);\n        });\n      })\n      .catch(error => {\n        reject(error);\n      });\n  }, cb);\n};\n\n/**\n * Load iCal data from a file and parse it.\n *\n * @param {string} filename   - File path to load.\n * @param {icsCallback} [cb]  - Callback function.\n *                              If no callback is provided a promise will be returned.\n *\n * @returns {optionalPromise} Promise is returned if no callback is passed.\n */\nasync.parseFile = function (filename, cb) {\n  return promiseCallback((resolve, reject) => {\n    fs.readFile(filename, 'utf8', (error, data) => {\n      if (error) {\n        reject(error);\n        return;\n      }\n\n      ical.parseICS(data, (error, ics) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(ics);\n      });\n    });\n  }, cb);\n};\n\n/**\n * Parse iCal data from a string.\n *\n * @param {string} data       - String containing iCal data.\n * @param {icsCallback} [cb]  - Callback function.\n *                              If no callback is provided a promise will be returned.\n *\n * @returns {optionalPromise} Promise is returned if no callback is passed.\n */\nasync.parseICS = function (data, cb) {\n  return promiseCallback((resolve, reject) => {\n    ical.parseICS(data, (error, ics) => {\n      if (error) {\n        reject(error);\n        return;\n      }\n\n      resolve(ics);\n    });\n  }, cb);\n};\n\n/**\n * Load iCal data from a file and parse it.\n *\n * @param {string} filename   - File path to load.\n *\n * @returns {iCalData} Parsed iCal data.\n */\nsync.parseFile = function (filename) {\n  const data = fs.readFileSync(filename, 'utf8');\n  return ical.parseICS(data);\n};\n\n/**\n * Parse iCal data from a string.\n *\n * @param {string} data - String containing iCal data.\n *\n * @returns {iCalData} Parsed iCal data.\n */\nsync.parseICS = function (data) {\n  return ical.parseICS(data);\n};\n\n/**\n * Load iCal data from a file and parse it.\n *\n * @param {string} filename   - File path to load.\n * @param {icsCallback} [cb]  - Callback function.\n *                              If no callback is provided this function runs synchronously.\n *\n * @returns {iCalData|undefined} Parsed iCal data or undefined if a callback is being used.\n */\nautodetect.parseFile = function (filename, cb) {\n  if (!cb) {\n    return sync.parseFile(filename);\n  }\n\n  async.parseFile(filename, cb);\n};\n\n/**\n * Parse iCal data from a string.\n *\n * @param {string} data       - String containing iCal data.\n * @param {icsCallback} [cb]  - Callback function.\n *                              If no callback is provided this function runs synchronously.\n *\n * @returns {iCalData|undefined} Parsed iCal data or undefined if a callback is being used.\n */\nautodetect.parseICS = function (data, cb) {\n  if (!cb) {\n    return sync.parseICS(data);\n  }\n\n  async.parseICS(data, cb);\n};\n\n// Export api functions\nmodule.exports = {\n  // Autodetect\n  fromURL: async.fromURL,\n  parseFile: autodetect.parseFile,\n  parseICS: autodetect.parseICS,\n  // Sync\n  sync,\n  // Async\n  async,\n  // Other backwards compat things\n  objectHandlers: ical.objectHandlers,\n  handleObject: ical.handleObject,\n  parseLines: ical.parseLines\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1pY2FsL25vZGUtaWNhbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixjQUFjLG1CQUFPLENBQUMsNkRBQU87QUFDN0IsYUFBYSxtQkFBTyxDQUFDLHlEQUFXOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkI7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBLE1BQU07QUFDTjtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdDQUFnQztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQixFQUFFLG9CQUFvQjtBQUNyRTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVzdC8uL25vZGVfbW9kdWxlcy9ub2RlLWljYWwvbm9kZS1pY2FsLmpzPzFlNWQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgYXhpb3MgPSByZXF1aXJlKCdheGlvcycpO1xuY29uc3QgaWNhbCA9IHJlcXVpcmUoJy4vaWNhbC5qcycpO1xuXG4vKipcbiAqIElDYWwgZXZlbnQgb2JqZWN0LlxuICpcbiAqIFRoZXNlIHR3byBmaWVsZHMgYXJlIGFsd2F5cyBwcmVzZW50OlxuICogIC0gdHlwZVxuICogIC0gcGFyYW1zXG4gKlxuICogVGhlIHJlc3Qgb2YgdGhlIGZpZWxkcyBtYXkgb3IgbWF5IG5vdCBiZSBwcmVzZW50IGRlcGVuZGluZyBvbiB0aGUgaW5wdXQuXG4gKiBEbyBub3QgYXNzdW1lIGFueSBvZiB0aGVzZSBmaWVsZHMgYXJlIHZhbGlkIGFuZCBjaGVjayB0aGVtIGJlZm9yZSB1c2luZy5cbiAqIE1vc3QgdHlwZXMgYXJlIHNpbXBseSB0aGVyZSBhcyBhIGdlbmVyYWwgZ3VpZGUgZm9yIElERXMgYW5kIHVzZXJzLlxuICpcbiAqIEB0eXBlZGVmIGlDYWxFdmVudFxuICogQHR5cGUge29iamVjdH1cbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAgICAgICAgICAgLSBUeXBlIG9mIGV2ZW50LlxuICogQHByb3BlcnR5IHtBcnJheX0gcGFyYW1zICAgICAgICAgIC0gRXh0cmEgZXZlbnQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcHJvcGVydHkgez9vYmplY3R9IHN0YXJ0ICAgICAgICAgLSBXaGVuIHRoaXMgZXZlbnQgc3RhcnRzLlxuICogQHByb3BlcnR5IHs/b2JqZWN0fSBlbmQgICAgICAgICAgIC0gV2hlbiB0aGlzIGV2ZW50IGVuZHMuXG4gKlxuICogQHByb3BlcnR5IHs/c3RyaW5nfSBzdW1tYXJ5ICAgICAgIC0gRXZlbnQgc3VtbWFyeSBzdHJpbmcuXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IGRlc2NyaXB0aW9uICAgLSBFdmVudCBkZXNjcmlwdGlvbi5cbiAqXG4gKiBAcHJvcGVydHkgez9vYmplY3R9IGR0c3RhbXAgICAgICAgLSBEVFNUQU1QIGZpZWxkIG9mIHRoaXMgZXZlbnQuXG4gKlxuICogQHByb3BlcnR5IHs/b2JqZWN0fSBjcmVhdGVkICAgICAgIC0gV2hlbiB0aGlzIGV2ZW50IHdhcyBjcmVhdGVkLlxuICogQHByb3BlcnR5IHs/b2JqZWN0fSBsYXN0bW9kaWZpZWQgIC0gV2hlbiB0aGlzIGV2ZW50IHdhcyBsYXN0IG1vZGlmaWVkLlxuICpcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gdWlkICAgICAgICAgICAtIFVuaXF1ZSBldmVudCBpZGVudGlmaWVyLlxuICpcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gc3RhdHVzICAgICAgICAtIEV2ZW50IHN0YXR1cy5cbiAqXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHNlcXVlbmNlICAgICAgLSBFdmVudCBzZXF1ZW5jZS5cbiAqXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IHVybCAgICAgICAgICAgLSBVUkwgb2YgdGhpcyBldmVudC5cbiAqXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IGxvY2F0aW9uICAgICAgLSBXaGVyZSB0aGlzIGV2ZW50IG9jY3Vycy5cbiAqIEBwcm9wZXJ0eSB7P3tcbiAqICAgICBsYXQ6IG51bWJlciwgbG9uOiBudW1iZXJcbiAqIH19IGdlbyAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIExhdC9sb24gbG9jYXRpb24gb2YgdGhpcyBldmVudC5cbiAqXG4gKiBAcHJvcGVydHkgez9BcnJheS48c3RyaW5nPn0gICAgICAgLSBBcnJheSBvZiBldmVudCBjYXRhZ29yaWVzLlxuICovXG4vKipcbiAqIE9iamVjdCBjb250YWluaW5nIGlDYWwgZXZlbnRzLlxuICogQHR5cGVkZWYge09iamVjdC48c3RyaW5nLCBpQ2FsRXZlbnQ+fSBpQ2FsRGF0YVxuICovXG4vKipcbiAqIENhbGxiYWNrIGZvciBpQ2FsIHBhcnNpbmcgZnVuY3Rpb25zIHdpdGggZXJyb3IgYW5kIGlDYWwgZGF0YSBhcyBhIEphdmFTY3JpcHQgb2JqZWN0LlxuICogQGNhbGxiYWNrIGljc0NhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7aUNhbERhdGF9IGljc1xuICovXG4vKipcbiAqIEEgUHJvbWlzZSB0aGF0IGlzIHVuZGVmaW5lZCBpZiBhIGNvbXBhdGlibGUgY2FsbGJhY2sgaXMgcGFzc2VkLlxuICogQHR5cGVkZWYgeyhQcm9taXNlLjxpQ2FsRGF0YT58dW5kZWZpbmVkKX0gb3B0aW9uYWxQcm9taXNlXG4gKi9cblxuLy8gdXRpbGl0eSB0byBhbGxvdyBjYWxsYmFja3MgdG8gYmUgdXNlZCBmb3IgcHJvbWlzZXNcbmZ1bmN0aW9uIHByb21pc2VDYWxsYmFjayhmbiwgY2IpIHtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZuKTtcbiAgaWYgKCFjYikge1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgcHJvbWlzZVxuICAgIC50aGVuKHJldHVyblZhbHVlID0+IHtcbiAgICAgIGNiKG51bGwsIHJldHVyblZhbHVlKTtcbiAgICB9KVxuICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICBjYihlcnJvciwgbnVsbCk7XG4gICAgfSk7XG59XG5cbi8vIFN5bmMgZnVuY3Rpb25zXG5jb25zdCBzeW5jID0ge307XG4vLyBBc3luYyBmdW5jdGlvbnNcbmNvbnN0IGFzeW5jID0ge307XG4vLyBBdXRvLWRldGVjdCBmdW5jdGlvbnMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuY29uc3QgYXV0b2RldGVjdCA9IHt9O1xuXG4vKipcbiAqIERvd25sb2FkIGFuIGlDYWwgZmlsZSBmcm9tIHRoZSB3ZWIgYW5kIHBhcnNlIGl0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgICAgICAgICAgICAgICAgLSBVUkwgb2YgZmlsZSB0byByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R8aWNzQ2FsbGJhY2t9IFtvcHRzXSAtIE9wdGlvbnMgdG8gcGFzcyB0byBheGlvcy5nZXQoKSBmcm9tIG5wbTpheGlvcy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbHRlcm5hdGl2ZWx5IHlvdSBjYW4gcGFzcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZGlyZWN0bHkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWQgYSBwcm9taXNlIHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge2ljc0NhbGxiYWNrfSBbY2JdICAgICAgICAgIC0gQ2FsbGJhY2sgZnVuY3Rpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWQgYSBwcm9taXNlIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogQHJldHVybnMge29wdGlvbmFsUHJvbWlzZX0gUHJvbWlzZSBpcyByZXR1cm5lZCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWQuXG4gKi9cbmFzeW5jLmZyb21VUkwgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zLCBjYikge1xuICByZXR1cm4gcHJvbWlzZUNhbGxiYWNrKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBheGlvcy5nZXQodXJsLCBvcHRpb25zKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAvLyBJZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgLy8gYWxsIG9rIHN0YXR1cyBjb2RlcyBzaG91bGQgYmUgYWNjZXB0ZWQgKGFueSAyWFggY29kZSlcbiAgICAgICAgaWYgKE1hdGguZmxvb3IocmVzcG9uc2Uuc3RhdHVzIC8gMTAwKSAhPT0gMikge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfSlcbiAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICBpY2FsLnBhcnNlSUNTKGRhdGEsIChlcnJvciwgaWNzKSA9PiB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc29sdmUoaWNzKTtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH0pO1xuICB9LCBjYik7XG59O1xuXG4vKipcbiAqIExvYWQgaUNhbCBkYXRhIGZyb20gYSBmaWxlIGFuZCBwYXJzZSBpdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgICAtIEZpbGUgcGF0aCB0byBsb2FkLlxuICogQHBhcmFtIHtpY3NDYWxsYmFja30gW2NiXSAgLSBDYWxsYmFjayBmdW5jdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWQgYSBwcm9taXNlIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogQHJldHVybnMge29wdGlvbmFsUHJvbWlzZX0gUHJvbWlzZSBpcyByZXR1cm5lZCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWQuXG4gKi9cbmFzeW5jLnBhcnNlRmlsZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgY2IpIHtcbiAgcmV0dXJuIHByb21pc2VDYWxsYmFjaygocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMucmVhZEZpbGUoZmlsZW5hbWUsICd1dGY4JywgKGVycm9yLCBkYXRhKSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpY2FsLnBhcnNlSUNTKGRhdGEsIChlcnJvciwgaWNzKSA9PiB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZShpY3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIGNiKTtcbn07XG5cbi8qKlxuICogUGFyc2UgaUNhbCBkYXRhIGZyb20gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgICAgICAgLSBTdHJpbmcgY29udGFpbmluZyBpQ2FsIGRhdGEuXG4gKiBAcGFyYW0ge2ljc0NhbGxiYWNrfSBbY2JdICAtIENhbGxiYWNrIGZ1bmN0aW9uLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBubyBjYWxsYmFjayBpcyBwcm92aWRlZCBhIHByb21pc2Ugd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBAcmV0dXJucyB7b3B0aW9uYWxQcm9taXNlfSBQcm9taXNlIGlzIHJldHVybmVkIGlmIG5vIGNhbGxiYWNrIGlzIHBhc3NlZC5cbiAqL1xuYXN5bmMucGFyc2VJQ1MgPSBmdW5jdGlvbiAoZGF0YSwgY2IpIHtcbiAgcmV0dXJuIHByb21pc2VDYWxsYmFjaygocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWNhbC5wYXJzZUlDUyhkYXRhLCAoZXJyb3IsIGljcykgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShpY3MpO1xuICAgIH0pO1xuICB9LCBjYik7XG59O1xuXG4vKipcbiAqIExvYWQgaUNhbCBkYXRhIGZyb20gYSBmaWxlIGFuZCBwYXJzZSBpdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgICAtIEZpbGUgcGF0aCB0byBsb2FkLlxuICpcbiAqIEByZXR1cm5zIHtpQ2FsRGF0YX0gUGFyc2VkIGlDYWwgZGF0YS5cbiAqL1xuc3luYy5wYXJzZUZpbGUgPSBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcbiAgY29uc3QgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyhmaWxlbmFtZSwgJ3V0ZjgnKTtcbiAgcmV0dXJuIGljYWwucGFyc2VJQ1MoZGF0YSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGlDYWwgZGF0YSBmcm9tIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gU3RyaW5nIGNvbnRhaW5pbmcgaUNhbCBkYXRhLlxuICpcbiAqIEByZXR1cm5zIHtpQ2FsRGF0YX0gUGFyc2VkIGlDYWwgZGF0YS5cbiAqL1xuc3luYy5wYXJzZUlDUyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHJldHVybiBpY2FsLnBhcnNlSUNTKGRhdGEpO1xufTtcblxuLyoqXG4gKiBMb2FkIGlDYWwgZGF0YSBmcm9tIGEgZmlsZSBhbmQgcGFyc2UgaXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lICAgLSBGaWxlIHBhdGggdG8gbG9hZC5cbiAqIEBwYXJhbSB7aWNzQ2FsbGJhY2t9IFtjYl0gIC0gQ2FsbGJhY2sgZnVuY3Rpb24uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIG5vIGNhbGxiYWNrIGlzIHByb3ZpZGVkIHRoaXMgZnVuY3Rpb24gcnVucyBzeW5jaHJvbm91c2x5LlxuICpcbiAqIEByZXR1cm5zIHtpQ2FsRGF0YXx1bmRlZmluZWR9IFBhcnNlZCBpQ2FsIGRhdGEgb3IgdW5kZWZpbmVkIGlmIGEgY2FsbGJhY2sgaXMgYmVpbmcgdXNlZC5cbiAqL1xuYXV0b2RldGVjdC5wYXJzZUZpbGUgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGNiKSB7XG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gc3luYy5wYXJzZUZpbGUoZmlsZW5hbWUpO1xuICB9XG5cbiAgYXN5bmMucGFyc2VGaWxlKGZpbGVuYW1lLCBjYik7XG59O1xuXG4vKipcbiAqIFBhcnNlIGlDYWwgZGF0YSBmcm9tIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhICAgICAgIC0gU3RyaW5nIGNvbnRhaW5pbmcgaUNhbCBkYXRhLlxuICogQHBhcmFtIHtpY3NDYWxsYmFja30gW2NiXSAgLSBDYWxsYmFjayBmdW5jdGlvbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWQgdGhpcyBmdW5jdGlvbiBydW5zIHN5bmNocm9ub3VzbHkuXG4gKlxuICogQHJldHVybnMge2lDYWxEYXRhfHVuZGVmaW5lZH0gUGFyc2VkIGlDYWwgZGF0YSBvciB1bmRlZmluZWQgaWYgYSBjYWxsYmFjayBpcyBiZWluZyB1c2VkLlxuICovXG5hdXRvZGV0ZWN0LnBhcnNlSUNTID0gZnVuY3Rpb24gKGRhdGEsIGNiKSB7XG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gc3luYy5wYXJzZUlDUyhkYXRhKTtcbiAgfVxuXG4gIGFzeW5jLnBhcnNlSUNTKGRhdGEsIGNiKTtcbn07XG5cbi8vIEV4cG9ydCBhcGkgZnVuY3Rpb25zXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gQXV0b2RldGVjdFxuICBmcm9tVVJMOiBhc3luYy5mcm9tVVJMLFxuICBwYXJzZUZpbGU6IGF1dG9kZXRlY3QucGFyc2VGaWxlLFxuICBwYXJzZUlDUzogYXV0b2RldGVjdC5wYXJzZUlDUyxcbiAgLy8gU3luY1xuICBzeW5jLFxuICAvLyBBc3luY1xuICBhc3luYyxcbiAgLy8gT3RoZXIgYmFja3dhcmRzIGNvbXBhdCB0aGluZ3NcbiAgb2JqZWN0SGFuZGxlcnM6IGljYWwub2JqZWN0SGFuZGxlcnMsXG4gIGhhbmRsZU9iamVjdDogaWNhbC5oYW5kbGVPYmplY3QsXG4gIHBhcnNlTGluZXM6IGljYWwucGFyc2VMaW5lc1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-ical/node-ical.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-ical/windowsZones.json":
/*!**************************************************!*\
  !*** ./node_modules/node-ical/windowsZones.json ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"Dateline Standard Time":{"iana":["Etc/GMT+12"]},"UTC-11":{"iana":["Etc/GMT+11"]},"Aleutian Standard Time":{"iana":["America/Adak"]},"Hawaiian Standard Time":{"iana":["Pacific/Honolulu"]},"Marquesas Standard Time":{"iana":["Pacific/Marquesas"]},"Alaskan Standard Time":{"iana":["America/Anchorage"]},"UTC-09":{"iana":["Etc/GMT+9"]},"Pacific Standard Time (Mexico)":{"iana":["America/Tijuana"]},"UTC-08":{"iana":["Etc/GMT+8"]},"Pacific Standard Time":{"iana":["America/Los_Angeles"]},"US Mountain Standard Time":{"iana":["America/Phoenix"]},"Mountain Standard Time (Mexico)":{"iana":["America/Mazatlan"]},"Mountain Standard Time":{"iana":["America/Denver"]},"Yukon Standard Time":{"iana":["America/Whitehorse"]},"Central America Standard Time":{"iana":["America/Guatemala"]},"Central Standard Time":{"iana":["America/Chicago"]},"Easter Island Standard Time":{"iana":["Pacific/Easter"]},"Central Standard Time (Mexico)":{"iana":["America/Mexico_City"]},"Canada Central Standard Time":{"iana":["America/Regina"]},"SA Pacific Standard Time":{"iana":["America/Bogota"]},"Eastern Standard Time (Mexico)":{"iana":["America/Cancun"]},"Eastern Standard Time":{"iana":["America/New_York"]},"Haiti Standard Time":{"iana":["America/Port-au-Prince"]},"Cuba Standard Time":{"iana":["America/Havana"]},"US Eastern Standard Time":{"iana":["America/Indianapolis"]},"Turks And Caicos Standard Time":{"iana":["America/Grand_Turk"]},"Paraguay Standard Time":{"iana":["America/Asuncion"]},"Atlantic Standard Time":{"iana":["America/Halifax"]},"Venezuela Standard Time":{"iana":["America/Caracas"]},"Central Brazilian Standard Time":{"iana":["America/Cuiaba"]},"SA Western Standard Time":{"iana":["America/La_Paz"]},"Pacific SA Standard Time":{"iana":["America/Santiago"]},"Newfoundland Standard Time":{"iana":["America/St_Johns"]},"Tocantins Standard Time":{"iana":["America/Araguaina"]},"E. South America Standard Time":{"iana":["America/Sao_Paulo"]},"SA Eastern Standard Time":{"iana":["America/Cayenne"]},"Argentina Standard Time":{"iana":["America/Buenos_Aires"]},"Greenland Standard Time":{"iana":["America/Godthab"]},"Montevideo Standard Time":{"iana":["America/Montevideo"]},"Magallanes Standard Time":{"iana":["America/Punta_Arenas"]},"Saint Pierre Standard Time":{"iana":["America/Miquelon"]},"Bahia Standard Time":{"iana":["America/Bahia"]},"UTC-02":{"iana":["Etc/GMT+2"]},"Azores Standard Time":{"iana":["Atlantic/Azores"]},"Cape Verde Standard Time":{"iana":["Atlantic/Cape_Verde"]},"UTC":{"iana":["Etc/UTC"]},"GMT Standard Time":{"iana":["Europe/London"]},"Greenwich Standard Time":{"iana":["Atlantic/Reykjavik"]},"Sao Tome Standard Time":{"iana":["Africa/Sao_Tome"]},"Morocco Standard Time":{"iana":["Africa/Casablanca"]},"W. Europe Standard Time":{"iana":["Europe/Berlin"]},"Central Europe Standard Time":{"iana":["Europe/Budapest"]},"Romance Standard Time":{"iana":["Europe/Paris"]},"Central European Standard Time":{"iana":["Europe/Warsaw"]},"W. Central Africa Standard Time":{"iana":["Africa/Lagos"]},"Jordan Standard Time":{"iana":["Asia/Amman"]},"GTB Standard Time":{"iana":["Europe/Bucharest"]},"Middle East Standard Time":{"iana":["Asia/Beirut"]},"Egypt Standard Time":{"iana":["Africa/Cairo"]},"E. Europe Standard Time":{"iana":["Europe/Chisinau"]},"Syria Standard Time":{"iana":["Asia/Damascus"]},"West Bank Standard Time":{"iana":["Asia/Hebron"]},"South Africa Standard Time":{"iana":["Africa/Johannesburg"]},"FLE Standard Time":{"iana":["Europe/Kiev"]},"Israel Standard Time":{"iana":["Asia/Jerusalem"]},"South Sudan Standard Time":{"iana":["Africa/Juba"]},"Kaliningrad Standard Time":{"iana":["Europe/Kaliningrad"]},"Sudan Standard Time":{"iana":["Africa/Khartoum"]},"Libya Standard Time":{"iana":["Africa/Tripoli"]},"Namibia Standard Time":{"iana":["Africa/Windhoek"]},"Arabic Standard Time":{"iana":["Asia/Baghdad"]},"Turkey Standard Time":{"iana":["Europe/Istanbul"]},"Arab Standard Time":{"iana":["Asia/Riyadh"]},"Belarus Standard Time":{"iana":["Europe/Minsk"]},"Russian Standard Time":{"iana":["Europe/Moscow"]},"E. Africa Standard Time":{"iana":["Africa/Nairobi"]},"Iran Standard Time":{"iana":["Asia/Tehran"]},"Arabian Standard Time":{"iana":["Asia/Dubai"]},"Astrakhan Standard Time":{"iana":["Europe/Astrakhan"]},"Azerbaijan Standard Time":{"iana":["Asia/Baku"]},"Russia Time Zone 3":{"iana":["Europe/Samara"]},"Mauritius Standard Time":{"iana":["Indian/Mauritius"]},"Saratov Standard Time":{"iana":["Europe/Saratov"]},"Georgian Standard Time":{"iana":["Asia/Tbilisi"]},"Volgograd Standard Time":{"iana":["Europe/Volgograd"]},"Caucasus Standard Time":{"iana":["Asia/Yerevan"]},"Afghanistan Standard Time":{"iana":["Asia/Kabul"]},"West Asia Standard Time":{"iana":["Asia/Tashkent"]},"Ekaterinburg Standard Time":{"iana":["Asia/Yekaterinburg"]},"Pakistan Standard Time":{"iana":["Asia/Karachi"]},"Qyzylorda Standard Time":{"iana":["Asia/Qyzylorda"]},"India Standard Time":{"iana":["Asia/Calcutta"]},"Sri Lanka Standard Time":{"iana":["Asia/Colombo"]},"Nepal Standard Time":{"iana":["Asia/Katmandu"]},"Central Asia Standard Time":{"iana":["Asia/Almaty"]},"Bangladesh Standard Time":{"iana":["Asia/Dhaka"]},"Omsk Standard Time":{"iana":["Asia/Omsk"]},"Myanmar Standard Time":{"iana":["Asia/Rangoon"]},"SE Asia Standard Time":{"iana":["Asia/Bangkok"]},"Altai Standard Time":{"iana":["Asia/Barnaul"]},"W. Mongolia Standard Time":{"iana":["Asia/Hovd"]},"North Asia Standard Time":{"iana":["Asia/Krasnoyarsk"]},"N. Central Asia Standard Time":{"iana":["Asia/Novosibirsk"]},"Tomsk Standard Time":{"iana":["Asia/Tomsk"]},"China Standard Time":{"iana":["Asia/Shanghai"]},"North Asia East Standard Time":{"iana":["Asia/Irkutsk"]},"Singapore Standard Time":{"iana":["Asia/Singapore"]},"W. Australia Standard Time":{"iana":["Australia/Perth"]},"Taipei Standard Time":{"iana":["Asia/Taipei"]},"Ulaanbaatar Standard Time":{"iana":["Asia/Ulaanbaatar"]},"Aus Central W. Standard Time":{"iana":["Australia/Eucla"]},"Transbaikal Standard Time":{"iana":["Asia/Chita"]},"Tokyo Standard Time":{"iana":["Asia/Tokyo"]},"North Korea Standard Time":{"iana":["Asia/Pyongyang"]},"Korea Standard Time":{"iana":["Asia/Seoul"]},"Yakutsk Standard Time":{"iana":["Asia/Yakutsk"]},"Cen. Australia Standard Time":{"iana":["Australia/Adelaide"]},"AUS Central Standard Time":{"iana":["Australia/Darwin"]},"E. Australia Standard Time":{"iana":["Australia/Brisbane"]},"AUS Eastern Standard Time":{"iana":["Australia/Sydney"]},"West Pacific Standard Time":{"iana":["Pacific/Port_Moresby"]},"Tasmania Standard Time":{"iana":["Australia/Hobart"]},"Vladivostok Standard Time":{"iana":["Asia/Vladivostok"]},"Lord Howe Standard Time":{"iana":["Australia/Lord_Howe"]},"Bougainville Standard Time":{"iana":["Pacific/Bougainville"]},"Russia Time Zone 10":{"iana":["Asia/Srednekolymsk"]},"Magadan Standard Time":{"iana":["Asia/Magadan"]},"Norfolk Standard Time":{"iana":["Pacific/Norfolk"]},"Sakhalin Standard Time":{"iana":["Asia/Sakhalin"]},"Central Pacific Standard Time":{"iana":["Pacific/Guadalcanal"]},"Russia Time Zone 11":{"iana":["Asia/Kamchatka"]},"New Zealand Standard Time":{"iana":["Pacific/Auckland"]},"UTC+12":{"iana":["Etc/GMT-12"]},"Fiji Standard Time":{"iana":["Pacific/Fiji"]},"Chatham Islands Standard Time":{"iana":["Pacific/Chatham"]},"UTC+13":{"iana":["Etc/GMT-13"]},"Tonga Standard Time":{"iana":["Pacific/Tongatapu"]},"Samoa Standard Time":{"iana":["Pacific/Apia"]},"Line Islands Standard Time":{"iana":["Pacific/Kiritimati"]},"(UTC-12:00) International Date Line West":{"iana":["Etc/GMT+12"]},"(UTC-11:00) Midway Island, Samoa":{"iana":["Pacific/Apia"]},"(UTC-10:00) Hawaii":{"iana":["Pacific/Honolulu"]},"(UTC-09:00) Alaska":{"iana":["America/Anchorage"]},"(UTC-08:00) Pacific Time (US & Canada); Tijuana":{"iana":["America/Los_Angeles"]},"(UTC-08:00) Pacific Time (US and Canada); Tijuana":{"iana":["America/Los_Angeles"]},"(UTC-07:00) Mountain Time (US & Canada)":{"iana":["America/Denver"]},"(UTC-07:00) Mountain Time (US and Canada)":{"iana":["America/Denver"]},"(UTC-07:00) Chihuahua, La Paz, Mazatlan":{"iana":[null]},"(UTC-07:00) Arizona":{"iana":["America/Phoenix"]},"(UTC-06:00) Central Time (US & Canada)":{"iana":["America/Chicago"]},"(UTC-06:00) Central Time (US and Canada)":{"iana":["America/Chicago"]},"(UTC-06:00) Saskatchewan":{"iana":["America/Regina"]},"(UTC-06:00) Guadalajara, Mexico City, Monterrey":{"iana":[null]},"(UTC-06:00) Central America":{"iana":["America/Guatemala"]},"(UTC-05:00) Eastern Time (US & Canada)":{"iana":["America/New_York"]},"(UTC-05:00) Eastern Time (US and Canada)":{"iana":["America/New_York"]},"(UTC-05:00) Indiana (East)":{"iana":["America/Indianapolis"]},"(UTC-05:00) Bogota, Lima, Quito":{"iana":["America/Bogota"]},"(UTC-04:00) Atlantic Time (Canada)":{"iana":["America/Halifax"]},"(UTC-04:00) Georgetown, La Paz, San Juan":{"iana":["America/La_Paz"]},"(UTC-04:00) Santiago":{"iana":["America/Santiago"]},"(UTC-03:30) Newfoundland":{"iana":[null]},"(UTC-03:00) Brasilia":{"iana":["America/Sao_Paulo"]},"(UTC-03:00) Georgetown":{"iana":["America/Cayenne"]},"(UTC-03:00) Greenland":{"iana":["America/Godthab"]},"(UTC-02:00) Mid-Atlantic":{"iana":[null]},"(UTC-01:00) Azores":{"iana":["Atlantic/Azores"]},"(UTC-01:00) Cape Verde Islands":{"iana":["Atlantic/Cape_Verde"]},"(UTC) Greenwich Mean Time: Dublin, Edinburgh, Lisbon, London":{"iana":[null]},"(UTC) Monrovia, Reykjavik":{"iana":["Atlantic/Reykjavik"]},"(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague":{"iana":["Europe/Budapest"]},"(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb":{"iana":["Europe/Warsaw"]},"(UTC+01:00) Brussels, Copenhagen, Madrid, Paris":{"iana":["Europe/Paris"]},"(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna":{"iana":["Europe/Berlin"]},"(UTC+01:00) West Central Africa":{"iana":["Africa/Lagos"]},"(UTC+02:00) Minsk":{"iana":["Europe/Chisinau"]},"(UTC+02:00) Cairo":{"iana":["Africa/Cairo"]},"(UTC+02:00) Helsinki, Kiev, Riga, Sofia, Tallinn, Vilnius":{"iana":["Europe/Kiev"]},"(UTC+02:00) Athens, Bucharest, Istanbul":{"iana":["Europe/Bucharest"]},"(UTC+02:00) Jerusalem":{"iana":["Asia/Jerusalem"]},"(UTC+02:00) Harare, Pretoria":{"iana":["Africa/Johannesburg"]},"(UTC+03:00) Moscow, St. Petersburg, Volgograd":{"iana":["Europe/Moscow"]},"(UTC+03:00) Kuwait, Riyadh":{"iana":["Asia/Riyadh"]},"(UTC+03:00) Nairobi":{"iana":["Africa/Nairobi"]},"(UTC+03:00) Baghdad":{"iana":["Asia/Baghdad"]},"(UTC+03:30) Tehran":{"iana":["Asia/Tehran"]},"(UTC+04:00) Abu Dhabi, Muscat":{"iana":["Asia/Dubai"]},"(UTC+04:00) Baku, Tbilisi, Yerevan":{"iana":["Asia/Yerevan"]},"(UTC+04:30) Kabul":{"iana":[null]},"(UTC+05:00) Ekaterinburg":{"iana":["Asia/Yekaterinburg"]},"(UTC+05:00) Tashkent":{"iana":["Asia/Tashkent"]},"(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi":{"iana":["Asia/Calcutta"]},"(UTC+05:45) Kathmandu":{"iana":["Asia/Katmandu"]},"(UTC+06:00) Astana, Dhaka":{"iana":["Asia/Almaty"]},"(UTC+06:00) Sri Jayawardenepura":{"iana":["Asia/Colombo"]},"(UTC+06:00) Almaty, Novosibirsk":{"iana":["Asia/Novosibirsk"]},"(UTC+06:30) Yangon (Rangoon)":{"iana":["Asia/Rangoon"]},"(UTC+07:00) Bangkok, Hanoi, Jakarta":{"iana":["Asia/Bangkok"]},"(UTC+07:00) Krasnoyarsk":{"iana":["Asia/Krasnoyarsk"]},"(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi":{"iana":["Asia/Shanghai"]},"(UTC+08:00) Kuala Lumpur, Singapore":{"iana":["Asia/Singapore"]},"(UTC+08:00) Taipei":{"iana":["Asia/Taipei"]},"(UTC+08:00) Perth":{"iana":["Australia/Perth"]},"(UTC+08:00) Irkutsk, Ulaanbaatar":{"iana":["Asia/Irkutsk"]},"(UTC+09:00) Seoul":{"iana":["Asia/Seoul"]},"(UTC+09:00) Osaka, Sapporo, Tokyo":{"iana":["Asia/Tokyo"]},"(UTC+09:00) Yakutsk":{"iana":["Asia/Yakutsk"]},"(UTC+09:30) Darwin":{"iana":["Australia/Darwin"]},"(UTC+09:30) Adelaide":{"iana":["Australia/Adelaide"]},"(UTC+10:00) Canberra, Melbourne, Sydney":{"iana":["Australia/Sydney"]},"(GMT+10:00) Canberra, Melbourne, Sydney":{"iana":["Australia/Sydney"]},"(UTC+10:00) Brisbane":{"iana":["Australia/Brisbane"]},"(UTC+10:00) Hobart":{"iana":["Australia/Hobart"]},"(UTC+10:00) Vladivostok":{"iana":["Asia/Vladivostok"]},"(UTC+10:00) Guam, Port Moresby":{"iana":["Pacific/Port_Moresby"]},"(UTC+11:00) Magadan, Solomon Islands, New Caledonia":{"iana":["Pacific/Guadalcanal"]},"(UTC+12:00) Fiji, Kamchatka, Marshall Is.":{"iana":[null]},"(UTC+12:00) Auckland, Wellington":{"iana":["Pacific/Auckland"]},"(UTC+13:00) Nuku\'alofa":{"iana":["Pacific/Tongatapu"]},"(UTC-03:00) Buenos Aires":{"iana":["America/Buenos_Aires"]},"(UTC+02:00) Beirut":{"iana":["Asia/Beirut"]},"(UTC+02:00) Amman":{"iana":["Asia/Amman"]},"(UTC-06:00) Guadalajara, Mexico City, Monterrey - New":{"iana":["America/Mexico_City"]},"(UTC-07:00) Chihuahua, La Paz, Mazatlan - New":{"iana":["America/Mazatlan"]},"(UTC-08:00) Tijuana, Baja California":{"iana":["America/Tijuana"]},"(UTC+02:00) Windhoek":{"iana":["Africa/Windhoek"]},"(UTC+03:00) Tbilisi":{"iana":["Asia/Tbilisi"]},"(UTC-04:00) Manaus":{"iana":["America/Cuiaba"]},"(UTC-03:00) Montevideo":{"iana":["America/Montevideo"]},"(UTC+04:00) Yerevan":{"iana":[null]},"(UTC-04:30) Caracas":{"iana":["America/Caracas"]},"(UTC) Casablanca":{"iana":["Africa/Casablanca"]},"(UTC+05:00) Islamabad, Karachi":{"iana":["Asia/Karachi"]},"(UTC+04:00) Port Louis":{"iana":["Indian/Mauritius"]},"(UTC) Coordinated Universal Time":{"iana":["Etc/UTC"]},"(UTC-04:00) Asuncion":{"iana":["America/Asuncion"]},"(UTC+12:00) Petropavlovsk-Kamchatsky":{"iana":[null]}}');

/***/ })

};
;